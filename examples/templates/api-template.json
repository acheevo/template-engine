{
  "name": "go-api-template",
  "type": "go-api",
  "version": "1.0.0",
  "description": "Go REST API template with Gin and PostgreSQL",
  "variables": {
    "Author": {
      "type": "string",
      "required": false,
      "default": "Developer",
      "description": "Project author name"
    },
    "Description": {
      "type": "string",
      "required": false,
      "default": "A Go REST API application",
      "description": "Project description"
    },
    "GitHubRepo": {
      "type": "string",
      "required": true,
      "description": "GitHub repository (e.g., username/repo-name)"
    },
    "ProjectName": {
      "type": "string",
      "required": true,
      "description": "Name of the API project"
    }
  },
  "files": [
    {
      "path": ".claude/settings.local.json",
      "template": false,
      "content": "{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(mkdir:*)\",\n      \"Bash(go mod:*)\",\n      \"Bash(rm:*)\",\n      \"Bash(go build:*)\",\n      \"Bash(go test:*)\",\n      \"Bash(./bin/api:*)\",\n      \"Bash(go get:*)\",\n      \"Bash(make lint:*)\",\n      \"Bash(gofmt:*)\",\n      \"Bash(gofumpt:*)\",\n      \"Bash(git remote add:*)\",\n      \"Bash(git add:*)\"\n    ],\n    \"deny\": []\n  }\n}",
      "size": 363,
      "hash": "7a07e78a18e7a676537112b1d951057f7589bbef9165f73a25a04bc8a3cbcf2b"
    },
    {
      "path": ".github/ISSUE_TEMPLATE/bug_report.md",
      "template": false,
      "content": "---\nname: Bug report\nabout: Create a report to help us improve\ntitle: '[BUG] '\nlabels: 'bug'\nassignees: ''\n---\n\n## Bug Description\nA clear and concise description of what the bug is.\n\n## Steps to Reproduce\n1. Go to '...'\n2. Click on '....'\n3. Scroll down to '....'\n4. See error\n\n## Expected Behavior\nA clear and concise description of what you expected to happen.\n\n## Actual Behavior\nA clear and concise description of what actually happened.\n\n## Environment\n- **OS**: [e.g. Ubuntu 22.04, macOS 13.0]\n- **Go Version**: [e.g. 1.23.0]\n- **API Version**: [e.g. v1.2.3]\n- **Database**: [e.g. PostgreSQL 16.1]\n- **Deployment**: [e.g. Kubernetes, Docker Compose, Local]\n\n## Screenshots/Logs\nIf applicable, add screenshots or logs to help explain your problem.\n\n```\nPaste relevant logs here\n```\n\n## Additional Context\nAdd any other context about the problem here.\n\n## Possible Solution\nIf you have ideas on how to fix this, please describe them here.",
      "size": 943,
      "hash": "1acfb5ac27ed9fbc464512cfad166ba5fe27690a89c2af14353845d5e013ac22"
    },
    {
      "path": ".github/ISSUE_TEMPLATE/feature_request.md",
      "template": false,
      "content": "---\nname: Feature request\nabout: Suggest an idea for this project\ntitle: '[FEATURE] '\nlabels: 'enhancement'\nassignees: ''\n---\n\n## Feature Description\nA clear and concise description of what you want to happen.\n\n## Problem Statement\nA clear and concise description of what the problem is. Ex. I'm always frustrated when [...]\n\n## Proposed Solution\nA clear and concise description of what you want to happen.\n\n## Alternative Solutions\nA clear and concise description of any alternative solutions or features you've considered.\n\n## Use Cases\nDescribe the use cases for this feature:\n- Use case 1: ...\n- Use case 2: ...\n\n## Implementation Ideas\nIf you have ideas on how to implement this feature:\n- [ ] API changes needed\n- [ ] Database changes needed\n- [ ] Configuration changes needed\n- [ ] Breaking changes\n\n## Additional Context\nAdd any other context or screenshots about the feature request here.\n\n## Acceptance Criteria\n- [ ] Criterion 1\n- [ ] Criterion 2\n- [ ] Criterion 3",
      "size": 975,
      "hash": "9aea6a487ebd2913c6000660d5a1221021a4b6f1a0122c144868df3e7702563e"
    },
    {
      "path": ".github/PULL_REQUEST_TEMPLATE.md",
      "template": false,
      "content": "# Pull Request\n\n## Description\nBrief description of the changes and their purpose.\n\n## Type of Change\n- [ ] Bug fix (non-breaking change which fixes an issue)\n- [ ] New feature (non-breaking change which adds functionality)\n- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)\n- [ ] Documentation update\n- [ ] Performance improvement\n- [ ] Code refactoring\n\n## Related Issues\nFixes #(issue number)\n\n## Testing\n- [ ] Unit tests pass locally\n- [ ] Integration tests pass locally\n- [ ] Added tests for new functionality\n- [ ] Manual testing completed\n\n## Security\n- [ ] No sensitive data exposed\n- [ ] Authentication/authorization considered\n- [ ] Input validation implemented\n- [ ] SQL injection prevention verified\n\n## Performance\n- [ ] No performance regressions\n- [ ] Database queries optimized\n- [ ] Memory usage considered\n- [ ] Caching strategy implemented (if applicable)\n\n## Documentation\n- [ ] Code is self-documenting\n- [ ] Comments added for complex logic\n- [ ] API documentation updated (if applicable)\n- [ ] README updated (if applicable)\n\n## Deployment\n- [ ] Database migrations included (if applicable)\n- [ ] Environment variables documented\n- [ ] Kubernetes manifests updated (if applicable)\n- [ ] Breaking changes documented\n\n## Checklist\n- [ ] My code follows the project's coding standards\n- [ ] I have performed a self-review of my code\n- [ ] I have commented my code, particularly in hard-to-understand areas\n- [ ] I have made corresponding changes to the documentation\n- [ ] My changes generate no new warnings\n- [ ] I have added tests that prove my fix is effective or that my feature works\n- [ ] New and existing unit tests pass locally with my changes\n- [ ] Any dependent changes have been merged and published",
      "size": 1783,
      "hash": "d98395017e75493575ce56ef61e4180ae48964ef7c15726374e35072b4519329"
    },
    {
      "path": ".github/dependabot.yml",
      "template": false,
      "content": "version: 2\nupdates:\n  # Go modules\n  - package-ecosystem: \"gomod\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n      day: \"monday\"\n      time: \"06:00\"\n    open-pull-requests-limit: 10\n    reviewers:\n      - \"acheevo/backend-team\"\n    assignees:\n      - \"acheevo/backend-team\"\n    commit-message:\n      prefix: \"deps\"\n      include: \"scope\"\n    labels:\n      - \"dependencies\"\n      - \"go\"\n\n  # Docker\n  - package-ecosystem: \"docker\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n      day: \"monday\"\n      time: \"06:00\"\n    open-pull-requests-limit: 5\n    reviewers:\n      - \"acheevo/backend-team\"\n    commit-message:\n      prefix: \"deps\"\n      include: \"scope\"\n    labels:\n      - \"dependencies\"\n      - \"docker\"\n\n  # GitHub Actions\n  - package-ecosystem: \"github-actions\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n      day: \"monday\"\n      time: \"06:00\"\n    open-pull-requests-limit: 5\n    reviewers:\n      - \"acheevo/backend-team\"\n    commit-message:\n      prefix: \"deps\"\n      include: \"scope\"\n    labels:\n      - \"dependencies\"\n      - \"github-actions\"",
      "size": 1096,
      "hash": "fd0130e2b1c340120e9d7aea62fb00178bea8929b0f15ebebb3bdcf7f7669520"
    },
    {
      "path": ".github/workflows/ci.yml",
      "template": false,
      "content": "name: CI\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\nenv:\n  GO_VERSION: '1.23'\n\njobs:\n  test:\n    name: Test\n    runs-on: ubuntu-latest\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n\n    - name: Set up Go\n      uses: actions/setup-go@v5\n      with:\n        go-version: ${{ env.GO_VERSION }}\n        cache: true\n\n    - name: Install golangci-lint\n      uses: golangci/golangci-lint-action@v7\n      with:\n        version: v2.0.2\n\n    - name: Build\n      run: go build ./cmd/api\n\n    - name: Test\n      run: go test -race ./...\n\n  docker:\n    name: Docker Build\n    runs-on: ubuntu-latest\n    needs: test\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n\n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v3\n\n    - name: Build Docker image\n      uses: docker/build-push-action@v5\n      with:\n        context: .\n        push: false\n        tags: api-template:latest\n        cache-from: type=gha\n        cache-to: type=gha,mode=max",
      "size": 1042,
      "hash": "cb89c3549fa56f8110efa336f22291cbf0cbbb5891dbaa8d67f7921e21be4cd7"
    },
    {
      "path": "Dockerfile",
      "template": false,
      "content": "FROM golang:1.23-alpine AS builder\n\nWORKDIR /app\n\nRUN apk add --no-cache git ca-certificates\n\nCOPY go.mod go.sum ./\nRUN go mod download\n\nCOPY . .\n\nRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -ldflags=\"-w -s\" -o main ./cmd/api\n\nFROM alpine:latest\n\nRUN apk --no-cache add ca-certificates tzdata\n\nRUN addgroup -g 1001 -S appgroup \u0026\u0026 \\\n    adduser -u 1001 -S appuser -G appgroup\n\nWORKDIR /root/\n\nCOPY --from=builder /app/main .\n\nRUN chown appuser:appgroup main\n\nUSER appuser\n\nEXPOSE 8080\n\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n    CMD wget --quiet --tries=1 --spider http://localhost:8080/health || exit 1\n\nCMD [\"./main\"]",
      "size": 667,
      "hash": "69cc9ff458b7ba1e401035ad14bd4713c0d15ecf2b585e80c6b8a498a45dab8e"
    },
    {
      "path": "Makefile",
      "template": true,
      "content": ".PHONY: help build run test test-unit test-integration clean docker-build docker-run docker-stop docker-clean lint fmt vet tidy deps ci dev-setup\n\nhelp: ## Show this help message\n\t@echo 'Usage: make [target]'\n\t@echo ''\n\t@echo 'Targets:'\n\t@awk 'BEGIN {FS = \":.*?## \"} /^[a-zA-Z_-]+:.*?## / {printf \"  %-15s %s\\n\", $$1, $$2}' $(MAKEFILE_LIST)\n\nbuild: ## Build the application\n\tgo build -o bin/api ./cmd/api\n\nrun: ## Run the application\n\tgo run ./cmd/api\n\ntest: test-unit ## Run all tests\n\ntest-unit: ## Run unit tests\n\tgo test -race ./...\n\ntest-integration: ## Run integration tests\n\tgo test -v ./tests/integration/...\n\nclean: ## Clean build artifacts\n\trm -rf bin/\n\tgo clean\n\ndocker-build: ## Build Docker image\n\tdocker build -t api-template .\n\ndocker-run: ## Run with Docker Compose\n\tdocker-compose up --build\n\ndocker-stop: ## Stop Docker Compose\n\tdocker-compose down\n\ndocker-clean: ## Clean Docker containers and volumes\n\tdocker-compose down -v\n\tdocker rmi api-template 2\u003e/dev/null || true\n\nlint: ## Run golangci-lint\n\tgolangci-lint run\n\nfmt: ## Format code\n\tgo fmt ./...\n\nvet: ## Run go vet\n\tgo vet ./...\n\ntidy: ## Tidy go modules\n\tgo mod tidy\n\ndeps: ## Download dependencies\n\tgo mod download\n\nci: lint build test ## Run CI pipeline locally\n\ndev-setup: ## Set up development environment\n\tgo mod tidy\n\tgo mod download",
      "size": 1317,
      "hash": "d2ea2fbca40a92363effed73b414c90d8ecbc298e62fc192f11bdc96edfcd184",
      "mappings": [
        {
          "find": "docker build -t api-template .",
          "replace": "docker build -t {{.ProjectName | kebab}} ."
        },
        {
          "find": "docker rmi api-template",
          "replace": "docker rmi {{.ProjectName | kebab}}"
        }
      ]
    },
    {
      "path": "README.md",
      "template": true,
      "content": "# Go API Template\n\nA production-ready Go API template for microservices following clean architecture and domain-driven design principles.\n\n## Features\n\n### üèóÔ∏è Architecture\n- **Clean Architecture** with domain-driven design\n- **Microservice-ready** with service-to-service communication\n- **Health checks** with database connectivity monitoring\n- **Caching** for health checks to reduce database load\n\n### üîê Security\n- **JWT authentication** for service-to-service communication\n- **Rate limiting** with token bucket algorithm\n- **Request ID tracking** for distributed tracing\n- **Input validation** and sanitization\n\n### üöÄ Performance \u0026 Reliability\n- **Circuit breaker** pattern for resilient outbound calls\n- **Connection pooling** for database connections\n- **Prometheus metrics** collection\n- **Structured logging** with slog\n\n### üê≥ Deployment\n- **Docker** multi-stage builds\n- **Kubernetes** manifests with HPA, monitoring\n- **GitHub Actions** CI/CD pipeline\n- **Testcontainers** for integration testing\n\n## Quick Start\n\n### Prerequisites\n- Go 1.23+\n- Docker \u0026 Docker Compose\n- PostgreSQL (for production)\n\n### Local Development\n\n```bash\n# Clone the repository\ngit clone https://github.com/acheevo/api-template.git\ncd api-template\n\n# Set up development environment\nmake dev-setup\n\n# Run with Docker Compose (includes PostgreSQL)\nmake docker-run\n\n# Or run locally (requires PostgreSQL)\nexport DATABASE_URL=\"postgres://user:pass@localhost:5432/dbname?sslmode=disable\"\nmake run\n```\n\n### Available Commands\n\n```bash\nmake help           # Show all available commands\nmake build          # Build the application\nmake test           # Run tests (unit + integration)\nmake lint           # Run golangci-lint\nmake ci             # Run full CI pipeline locally\nmake docker-build   # Build Docker image\nmake docker-run     # Run with Docker Compose\n```\n\n## Configuration\n\nThe application uses environment variables for configuration:\n\n```env\n# Server\nHTTP_ADDR=:8080\nLOG_LEVEL=info\nENVIRONMENT=development\n\n# Database\nDATABASE_URL=postgres://user:pass@host:port/dbname?sslmode=disable\nDB_MAX_IDLE_CONNS=5\nDB_MAX_OPEN_CONNS=25\nDB_CONN_MAX_LIFETIME=300s\n\n# Authentication\nJWT_SECRET=your-secret-key\nJWT_EXPIRATION=24h\n\n# Service Identity (for service-to-service calls)\nSERVICE_NAME=api-template\nSERVICE_VERSION=1.0.0\n```\n\n## API Endpoints\n\n### Health \u0026 Monitoring\n- `GET /health` - Detailed health check (cached)\n- `GET /ready` - Readiness probe (always fresh)\n- `GET /live` - Liveness probe\n- `GET /metrics` - Prometheus metrics\n\n### API Routes (JWT Protected)\n- `GET /api/v1/info` - Service information with system metrics\n\n## Architecture Overview\n\n```\ncmd/\n‚îú‚îÄ‚îÄ api/                    # Application entry point\ninternal/\n‚îú‚îÄ‚îÄ auth/service/           # JWT service\n‚îú‚îÄ‚îÄ client/                 # HTTP client with circuit breaker\n‚îú‚îÄ‚îÄ health/                 # Health check domain\n‚îú‚îÄ‚îÄ info/                   # Service info domain\n‚îú‚îÄ‚îÄ middleware/             # HTTP middlewares\n‚îú‚îÄ‚îÄ http/                   # HTTP server setup\n‚îî‚îÄ‚îÄ shared/                 # Shared utilities\n    ‚îú‚îÄ‚îÄ config/             # Configuration management\n    ‚îú‚îÄ‚îÄ database/           # Database connection\n    ‚îî‚îÄ‚îÄ logger/             # Structured logging\ntests/\n‚îî‚îÄ‚îÄ integration/            # Integration tests with testcontainers\n```\n\n## Testing\n\nThe template includes comprehensive testing:\n\n```bash\n# Unit tests\nmake test-unit\n\n# Integration tests (uses testcontainers)\nmake test-integration\n\n# All tests\nmake test\n```\n\nIntegration tests automatically spin up PostgreSQL containers for realistic testing.\n\n## Deployment\n\n### Docker\n\n```bash\n# Build image\ndocker build -t api-template .\n\n# Run container\ndocker run -p 8080:8080 \\\n  -e DATABASE_URL=\"postgres://...\" \\\n  -e JWT_SECRET=\"your-secret\" \\\n  api-template\n```\n\n### Kubernetes\n\n```bash\n# Deploy to Kubernetes\nkubectl apply -f deployments/kubernetes/\n\n# Check status\nkubectl get pods -l app=api-template\n```\n\nThe Kubernetes manifests include:\n- Deployment with resource limits\n- Service for load balancing\n- HPA for auto-scaling\n- ServiceMonitor for Prometheus\n- ConfigMap and Secret management\n\n## Microservice Communication\n\nServices communicate using JWT tokens with shared secrets:\n\n```go\n// Example service-to-service call\nclient := client.NewHTTPClient(client.HTTPClientConfig{\n    ServiceName: \"my-service\",\n    ServiceID:   \"service-001\", \n    Version:     \"1.0.0\",\n    Environment: \"production\",\n    JWTService:  jwtService,\n    Logger:      logger,\n})\n\nresp, err := client.Get(ctx, \"http://other-service/api/v1/data\", nil)\n```\n\n## Monitoring \u0026 Observability\n\n### Metrics\n- HTTP request metrics (duration, status codes)\n- Circuit breaker state and counts\n- Database connection pool stats\n- Custom business metrics\n\n### Health Checks\n- **Health** (`/health`): Cached checks for performance\n- **Readiness** (`/ready`): Fresh checks for K8s probes\n- **Liveness** (`/live`): Simple alive check\n\n### Logging\nStructured JSON logging with:\n- Request ID correlation\n- HTTP request/response logging\n- Error tracking with context\n- Performance metrics\n\n## Development Guidelines\n\n### Adding New Domains\n1. Create domain in `internal/newdomain/`\n2. Follow clean architecture layers:\n   - `domain/` - entities and interfaces\n   - `service/` - business logic\n   - `transport/` - HTTP handlers\n3. Register routes in `internal/http/server.go`\n4. Add tests in `tests/integration/`\n\n### Code Standards\n- All code must pass `golangci-lint`\n- Maintain \u003e80% test coverage\n- Follow Go naming conventions\n- Use structured logging\n- Handle errors explicitly\n\n## Contributing\n\n1. Fork the repository\n2. Create a feature branch\n3. Make changes following the code standards\n4. Run `make ci` to ensure all checks pass\n5. Submit a pull request\n\n## License\n\nThis template is provided as-is for building microservices. Customize as needed for your organization.",
      "size": 5944,
      "hash": "d38cb642584ce1cae67ca39d19db5b0d99cb70cd5b83d43bf14f06c3125f4d1b",
      "mappings": [
        {
          "find": "# Go API Template",
          "replace": "# {{.ProjectName}}"
        },
        {
          "find": "git clone https://github.com/acheevo/api-template.git",
          "replace": "git clone https://github.com/{{.GitHubRepo}}.git"
        },
        {
          "find": "cd api-template",
          "replace": "cd {{.ProjectName | kebab}}"
        }
      ]
    },
    {
      "path": "cmd/api/main.go",
      "template": true,
      "content": "package main\n\nimport (\n\t\"context\"\n\t\"log/slog\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\tauthservice \"github.com/acheevo/api-template/internal/auth/service\"\n\t\"github.com/acheevo/api-template/internal/health/service\"\n\t\"github.com/acheevo/api-template/internal/health/transport\"\n\t\"github.com/acheevo/api-template/internal/http\"\n\tinfoservice \"github.com/acheevo/api-template/internal/info/service\"\n\tinfotransport \"github.com/acheevo/api-template/internal/info/transport\"\n\t\"github.com/acheevo/api-template/internal/shared/config\"\n\t\"github.com/acheevo/api-template/internal/shared/database\"\n\t\"github.com/acheevo/api-template/internal/shared/logger\"\n)\n\nfunc main() {\n\tcfg, err := config.Load()\n\tif err != nil {\n\t\tslog.Error(\"failed to load config\", \"error\", err)\n\t}\n\n\tappLogger := logger.New(cfg.LogLevel, cfg.IsDevelopment())\n\n\tdb, err := database.New(cfg.DatabaseDSN(), cfg.IsDevelopment())\n\tif err != nil {\n\t\tappLogger.Error(\"failed to connect to database\", \"error\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer db.Close()\n\n\t// Configure database connection pool\n\tif err := db.SetConnectionPool(\n\t\tcfg.DBMaxIdleConns,\n\t\tcfg.DBMaxOpenConns,\n\t\tcfg.DBConnMaxLifetimeDuration(),\n\t); err != nil {\n\t\tappLogger.Error(\"failed to configure database connection pool\", \"error\", err)\n\t\treturn\n\t}\n\n\t// Database migration is optional for microservices\n\t// Remove or customize based on your service needs\n\n\tjwtService := authservice.NewJWTService(cfg.JWTSecret, cfg.JWTExpirationDuration())\n\n\thealthService := service.NewHealthService(cfg, db, appLogger)\n\thealthHandler := transport.NewHealthHandler(healthService)\n\n\tinfoSvc := infoservice.NewInfoService(cfg, db, appLogger)\n\tinfoHandler := infotransport.NewInfoHandler(infoSvc)\n\n\tserver := http.NewServer(cfg, appLogger, healthHandler, infoHandler, jwtService)\n\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\n\tgo func() {\n\t\tif err := server.Start(); err != nil {\n\t\t\tappLogger.Error(\"server failed to start\", \"error\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t}()\n\n\tappLogger.Info(\"server started successfully\")\n\n\t\u003c-quit\n\tappLogger.Info(\"shutting down server...\")\n\n\tctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n\tdefer cancel()\n\n\tif err := server.Stop(ctx); err != nil {\n\t\tappLogger.Error(\"server forced to shutdown\", \"error\", err)\n\t} else {\n\t\tappLogger.Info(\"server exited gracefully\")\n\t}\n}\n",
      "size": 2354,
      "hash": "e8d6c258de5a5d18622df02d13100e85d874aa5609391786dbe2e97da168b467",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "docker-compose.yml",
      "template": true,
      "content": "version: '3.8'\n\nservices:\n  postgres:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_DB: api_template\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: postgres\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U postgres\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  api:\n    build: .\n    ports:\n      - \"8080:8080\"\n    environment:\n      DB_HOST: postgres\n      DB_PORT: 5432\n      DB_USER: postgres\n      DB_PASSWORD: postgres\n      DB_NAME: api_template\n      DB_SSL_MODE: disable\n      LOG_LEVEL: info\n      ENVIRONMENT: development\n    depends_on:\n      postgres:\n        condition: service_healthy\n    healthcheck:\n      test: [\"CMD\", \"wget\", \"--quiet\", \"--tries=1\", \"--spider\", \"http://localhost:8080/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\nvolumes:\n  postgres_data:",
      "size": 931,
      "hash": "d19a0189f81702416334df72c4f6b271dff08668ba2e85a3262da4a86ed65a17",
      "mappings": [
        {
          "find": "api-template",
          "replace": "{{.ProjectName | kebab}}"
        }
      ]
    },
    {
      "path": "go.mod",
      "template": true,
      "content": "module github.com/acheevo/api-template\n\ngo 1.23.0\n\ntoolchain go1.23.6\n\nrequire (\n\tgithub.com/gin-gonic/gin v1.10.1\n\tgithub.com/golang-jwt/jwt/v5 v5.2.1\n\tgithub.com/google/uuid v1.6.0\n\tgithub.com/kelseyhightower/envconfig v1.4.0\n\tgithub.com/prometheus/client_golang v1.20.5\n\tgithub.com/stretchr/testify v1.10.0\n\tgithub.com/testcontainers/testcontainers-go v0.38.0\n\tgithub.com/testcontainers/testcontainers-go/modules/postgres v0.38.0\n\tgolang.org/x/time v0.12.0\n\tgorm.io/driver/postgres v1.5.4\n\tgorm.io/gorm v1.25.5\n)\n\nrequire (\n\tdario.cat/mergo v1.0.1 // indirect\n\tgithub.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 // indirect\n\tgithub.com/Microsoft/go-winio v0.6.2 // indirect\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/bytedance/sonic v1.11.6 // indirect\n\tgithub.com/bytedance/sonic/loader v0.1.1 // indirect\n\tgithub.com/cenkalti/backoff/v4 v4.2.1 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.3.0 // indirect\n\tgithub.com/cloudwego/base64x v0.1.4 // indirect\n\tgithub.com/cloudwego/iasm v0.2.0 // indirect\n\tgithub.com/containerd/errdefs v1.0.0 // indirect\n\tgithub.com/containerd/errdefs/pkg v0.3.0 // indirect\n\tgithub.com/containerd/log v0.1.0 // indirect\n\tgithub.com/containerd/platforms v0.2.1 // indirect\n\tgithub.com/cpuguy83/dockercfg v0.3.2 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/distribution/reference v0.6.0 // indirect\n\tgithub.com/docker/docker v28.2.2+incompatible // indirect\n\tgithub.com/docker/go-connections v0.5.0 // indirect\n\tgithub.com/docker/go-units v0.5.0 // indirect\n\tgithub.com/ebitengine/purego v0.8.4 // indirect\n\tgithub.com/felixge/httpsnoop v1.0.4 // indirect\n\tgithub.com/gabriel-vasile/mimetype v1.4.3 // indirect\n\tgithub.com/gin-contrib/sse v0.1.0 // indirect\n\tgithub.com/go-logr/logr v1.4.2 // indirect\n\tgithub.com/go-logr/stdr v1.2.2 // indirect\n\tgithub.com/go-ole/go-ole v1.2.6 // indirect\n\tgithub.com/go-playground/locales v0.14.1 // indirect\n\tgithub.com/go-playground/universal-translator v0.18.1 // indirect\n\tgithub.com/go-playground/validator/v10 v10.20.0 // indirect\n\tgithub.com/goccy/go-json v0.10.2 // indirect\n\tgithub.com/gogo/protobuf v1.3.2 // indirect\n\tgithub.com/grpc-ecosystem/grpc-gateway/v2 v2.27.1 // indirect\n\tgithub.com/jackc/pgpassfile v1.0.0 // indirect\n\tgithub.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect\n\tgithub.com/jackc/pgx/v5 v5.5.4 // indirect\n\tgithub.com/jackc/puddle/v2 v2.2.1 // indirect\n\tgithub.com/jinzhu/inflection v1.0.0 // indirect\n\tgithub.com/jinzhu/now v1.1.5 // indirect\n\tgithub.com/json-iterator/go v1.1.12 // indirect\n\tgithub.com/klauspost/compress v1.18.0 // indirect\n\tgithub.com/klauspost/cpuid/v2 v2.2.7 // indirect\n\tgithub.com/leodido/go-urn v1.4.0 // indirect\n\tgithub.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0 // indirect\n\tgithub.com/magiconair/properties v1.8.10 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/moby/docker-image-spec v1.3.1 // indirect\n\tgithub.com/moby/go-archive v0.1.0 // indirect\n\tgithub.com/moby/patternmatcher v0.6.0 // indirect\n\tgithub.com/moby/sys/sequential v0.6.0 // indirect\n\tgithub.com/moby/sys/user v0.4.0 // indirect\n\tgithub.com/moby/sys/userns v0.1.0 // indirect\n\tgithub.com/moby/term v0.5.0 // indirect\n\tgithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect\n\tgithub.com/modern-go/reflect2 v1.0.2 // indirect\n\tgithub.com/morikuni/aec v1.0.0 // indirect\n\tgithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect\n\tgithub.com/opencontainers/go-digest v1.0.0 // indirect\n\tgithub.com/opencontainers/image-spec v1.1.1 // indirect\n\tgithub.com/pelletier/go-toml/v2 v2.2.2 // indirect\n\tgithub.com/pkg/errors v0.9.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c // indirect\n\tgithub.com/prometheus/client_model v0.6.1 // indirect\n\tgithub.com/prometheus/common v0.55.0 // indirect\n\tgithub.com/prometheus/procfs v0.15.1 // indirect\n\tgithub.com/rogpeppe/go-internal v1.14.1 // indirect\n\tgithub.com/shirou/gopsutil/v4 v4.25.5 // indirect\n\tgithub.com/sirupsen/logrus v1.9.3 // indirect\n\tgithub.com/tklauser/go-sysconf v0.3.12 // indirect\n\tgithub.com/tklauser/numcpus v0.6.1 // indirect\n\tgithub.com/twitchyliquid64/golang-asm v0.15.1 // indirect\n\tgithub.com/ugorji/go/codec v1.2.12 // indirect\n\tgithub.com/yusufpapurcu/wmi v1.2.4 // indirect\n\tgo.opentelemetry.io/auto/sdk v1.1.0 // indirect\n\tgo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0 // indirect\n\tgo.opentelemetry.io/otel v1.35.0 // indirect\n\tgo.opentelemetry.io/otel/metric v1.35.0 // indirect\n\tgo.opentelemetry.io/otel/sdk v1.35.0 // indirect\n\tgo.opentelemetry.io/otel/trace v1.35.0 // indirect\n\tgolang.org/x/arch v0.8.0 // indirect\n\tgolang.org/x/crypto v0.37.0 // indirect\n\tgolang.org/x/net v0.38.0 // indirect\n\tgolang.org/x/sync v0.15.0 // indirect\n\tgolang.org/x/sys v0.32.0 // indirect\n\tgolang.org/x/text v0.26.0 // indirect\n\tgoogle.golang.org/grpc v1.73.0 // indirect\n\tgoogle.golang.org/protobuf v1.36.6 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n",
      "size": 5078,
      "hash": "19dcb9c68b8cdd9e0c91f3cf293c414258285dfc68c0a3d3c0003b873d883025",
      "mappings": [
        {
          "find": "module github.com/acheevo/api-template",
          "replace": "module github.com/{{.GitHubRepo}}"
        }
      ]
    },
    {
      "path": "go.sum",
      "template": false,
      "content": "dario.cat/mergo v1.0.1 h1:Ra4+bf83h2ztPIQYNP99R6m+Y7KfnARDfID+a+vLl4s=\ndario.cat/mergo v1.0.1/go.mod h1:uNxQE+84aUszobStD9th8a29P2fMDhsBdgRYvZOxGmk=\ngithub.com/AdaLogics/go-fuzz-headers v0.0.0-20240806141605-e8a1dd7889d6 h1:He8afgbRMd7mFxO99hRNu+6tazq8nFF9lIwo9JFroBk=\ngithub.com/AdaLogics/go-fuzz-headers v0.0.0-20240806141605-e8a1dd7889d6/go.mod h1:8o94RPi1/7XTJvwPpRSzSUedZrtlirdB3r9Z20bi2f8=\ngithub.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 h1:UQHMgLO+TxOElx5B5HZ4hJQsoJ/PvUvKRhJHDQXO8P8=\ngithub.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=\ngithub.com/Microsoft/go-winio v0.6.2 h1:F2VQgta7ecxGYO8k3ZZz3RS8fVIXVxONVUPlNERoyfY=\ngithub.com/Microsoft/go-winio v0.6.2/go.mod h1:yd8OoFMLzJbo9gZq8j5qaps8bJ9aShtEA8Ipt1oGCvU=\ngithub.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/bytedance/sonic v1.11.6 h1:oUp34TzMlL+OY1OUWxHqsdkgC/Zfc85zGqw9siXjrc0=\ngithub.com/bytedance/sonic v1.11.6/go.mod h1:LysEHSvpvDySVdC2f87zGWf6CIKJcAvqab1ZaiQtds4=\ngithub.com/bytedance/sonic/loader v0.1.1 h1:c+e5Pt1k/cy5wMveRDyk2X4B9hF4g7an8N3zCYjJFNM=\ngithub.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=\ngithub.com/cenkalti/backoff/v4 v4.2.1 h1:y4OZtCnogmCPw98Zjyt5a6+QwPLGkiQsYW5oUqylYbM=\ngithub.com/cenkalti/backoff/v4 v4.2.1/go.mod h1:Y3VNntkOUPxTVeUxJ/G5vcM//AlwfmyYozVcomhLiZE=\ngithub.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=\ngithub.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/cloudwego/base64x v0.1.4 h1:jwCgWpFanWmN8xoIUHa2rtzmkd5J2plF/dnLS6Xd/0Y=\ngithub.com/cloudwego/base64x v0.1.4/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=\ngithub.com/cloudwego/iasm v0.2.0 h1:1KNIy1I1H9hNNFEEH3DVnI4UujN+1zjpuk6gwHLTssg=\ngithub.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=\ngithub.com/containerd/errdefs v1.0.0 h1:tg5yIfIlQIrxYtu9ajqY42W3lpS19XqdxRQeEwYG8PI=\ngithub.com/containerd/errdefs v1.0.0/go.mod h1:+YBYIdtsnF4Iw6nWZhJcqGSg/dwvV7tyJ/kCkyJ2k+M=\ngithub.com/containerd/errdefs/pkg v0.3.0 h1:9IKJ06FvyNlexW690DXuQNx2KA2cUJXx151Xdx3ZPPE=\ngithub.com/containerd/errdefs/pkg v0.3.0/go.mod h1:NJw6s9HwNuRhnjJhM7pylWwMyAkmCQvQ4GpJHEqRLVk=\ngithub.com/containerd/log v0.1.0 h1:TCJt7ioM2cr/tfR8GPbGf9/VRAX8D2B4PjzCpfX540I=\ngithub.com/containerd/log v0.1.0/go.mod h1:VRRf09a7mHDIRezVKTRCrOq78v577GXq3bSa3EhrzVo=\ngithub.com/containerd/platforms v0.2.1 h1:zvwtM3rz2YHPQsF2CHYM8+KtB5dvhISiXh5ZpSBQv6A=\ngithub.com/containerd/platforms v0.2.1/go.mod h1:XHCb+2/hzowdiut9rkudds9bE5yJ7npe7dG/wG+uFPw=\ngithub.com/cpuguy83/dockercfg v0.3.2 h1:DlJTyZGBDlXqUZ2Dk2Q3xHs/FtnooJJVaad2S9GKorA=\ngithub.com/cpuguy83/dockercfg v0.3.2/go.mod h1:sugsbF4//dDlL/i+S+rtpIWp+5h0BHJHfjj5/jFyUJc=\ngithub.com/creack/pty v1.1.18 h1:n56/Zwd5o6whRC5PMGretI4IdRLlmBXYNjScPaBgsbY=\ngithub.com/creack/pty v1.1.18/go.mod h1:MOBLtS5ELjhRRrroQr9kyvTxUAFNvYEK993ew/Vr4O4=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/distribution/reference v0.6.0 h1:0IXCQ5g4/QMHHkarYzh5l+u8T3t73zM5QvfrDyIgxBk=\ngithub.com/distribution/reference v0.6.0/go.mod h1:BbU0aIcezP1/5jX/8MP0YiH4SdvB5Y4f/wlDRiLyi3E=\ngithub.com/docker/docker v28.2.2+incompatible h1:CjwRSksz8Yo4+RmQ339Dp/D2tGO5JxwYeqtMOEe0LDw=\ngithub.com/docker/docker v28.2.2+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=\ngithub.com/docker/go-connections v0.5.0 h1:USnMq7hx7gwdVZq1L49hLXaFtUdTADjXGp+uj1Br63c=\ngithub.com/docker/go-connections v0.5.0/go.mod h1:ov60Kzw0kKElRwhNs9UlUHAE/F9Fe6GLaXnqyDdmEXc=\ngithub.com/docker/go-units v0.5.0 h1:69rxXcBk27SvSaaxTtLh/8llcHD8vYHT7WSdRZ/jvr4=\ngithub.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=\ngithub.com/ebitengine/purego v0.8.4 h1:CF7LEKg5FFOsASUj0+QwaXf8Ht6TlFxg09+S9wz0omw=\ngithub.com/ebitengine/purego v0.8.4/go.mod h1:iIjxzd6CiRiOG0UyXP+V1+jWqUXVjPKLAI0mRfJZTmQ=\ngithub.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=\ngithub.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=\ngithub.com/gabriel-vasile/mimetype v1.4.3 h1:in2uUcidCuFcDKtdcBxlR0rJ1+fsokWf+uqxgUFjbI0=\ngithub.com/gabriel-vasile/mimetype v1.4.3/go.mod h1:d8uq/6HKRL6CGdk+aubisF/M5GcPfT7nKyLpA0lbSSk=\ngithub.com/gin-contrib/sse v0.1.0 h1:Y/yl/+YNO8GZSjAhjMsSuLt29uWRFHdHYUb5lYOV9qE=\ngithub.com/gin-contrib/sse v0.1.0/go.mod h1:RHrZQHXnP2xjPF+u1gW/2HnVO7nvIa9PG3Gm+fLHvGI=\ngithub.com/gin-gonic/gin v1.10.1 h1:T0ujvqyCSqRopADpgPgiTT63DUQVSfojyME59Ei63pQ=\ngithub.com/gin-gonic/gin v1.10.1/go.mod h1:4PMNQiOhvDRa013RKVbsiNwoyezlm2rm0uX/T7kzp5Y=\ngithub.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=\ngithub.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=\ngithub.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=\ngithub.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=\ngithub.com/go-ole/go-ole v1.2.6 h1:/Fpf6oFPoeFik9ty7siob0G6Ke8QvQEuVcuChpwXzpY=\ngithub.com/go-ole/go-ole v1.2.6/go.mod h1:pprOEPIfldk/42T2oK7lQ4v4JSDwmV0As9GaiUsvbm0=\ngithub.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=\ngithub.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=\ngithub.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=\ngithub.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=\ngithub.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=\ngithub.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=\ngithub.com/go-playground/validator/v10 v10.20.0 h1:K9ISHbSaI0lyB2eWMPJo+kOS/FBExVwjEviJTixqxL8=\ngithub.com/go-playground/validator/v10 v10.20.0/go.mod h1:dbuPbCMFw/DrkbEynArYaCwl3amGuJotoKCe95atGMM=\ngithub.com/goccy/go-json v0.10.2 h1:CrxCmQqYDkv1z7lO7Wbh2HN93uovUHgrECaO5ZrCXAU=\ngithub.com/goccy/go-json v0.10.2/go.mod h1:6MelG93GURQebXPDq3khkgXZkazVtN9CRI+MGFi0w8I=\ngithub.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=\ngithub.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=\ngithub.com/golang-jwt/jwt/v5 v5.2.1 h1:OuVbFODueb089Lh128TAcimifWaLhJwVflnrgM17wHk=\ngithub.com/golang-jwt/jwt/v5 v5.2.1/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=\ngithub.com/google/go-cmp v0.5.6/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.7.0 h1:wk8382ETsv4JYUZwIsn6YpYiWiBsYLSJiTsyBybVuN8=\ngithub.com/google/go-cmp v0.7.0/go.mod h1:pXiqmnSA92OHEEa9HXL2W4E7lf9JzCmGVUdgjX3N/iU=\ngithub.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/grpc-ecosystem/grpc-gateway/v2 v2.27.1 h1:X5VWvz21y3gzm9Nw/kaUeku/1+uBhcekkmy4IkffJww=\ngithub.com/grpc-ecosystem/grpc-gateway/v2 v2.27.1/go.mod h1:Zanoh4+gvIgluNqcfMVTJueD4wSS5hT7zTt4Mrutd90=\ngithub.com/jackc/pgpassfile v1.0.0 h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=\ngithub.com/jackc/pgpassfile v1.0.0/go.mod h1:CEx0iS5ambNFdcRtxPj5JhEz+xB6uRky5eyVu/W2HEg=\ngithub.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a h1:bbPeKD0xmW/Y25WS6cokEszi5g+S0QxI/d45PkRi7Nk=\ngithub.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a/go.mod h1:5TJZWKEWniPve33vlWYSoGYefn3gLQRzjfDlhSJ9ZKM=\ngithub.com/jackc/pgx/v5 v5.5.4 h1:Xp2aQS8uXButQdnCMWNmvx6UysWQQC+u1EoizjguY+8=\ngithub.com/jackc/pgx/v5 v5.5.4/go.mod h1:ez9gk+OAat140fv9ErkZDYFWmXLfV+++K0uAOiwgm1A=\ngithub.com/jackc/puddle/v2 v2.2.1 h1:RhxXJtFG022u4ibrCSMSiu5aOq1i77R3OHKNJj77OAk=\ngithub.com/jackc/puddle/v2 v2.2.1/go.mod h1:vriiEXHvEE654aYKXXjOvZM39qJ0q+azkZFrfEOc3H4=\ngithub.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=\ngithub.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=\ngithub.com/jinzhu/now v1.1.5 h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=\ngithub.com/jinzhu/now v1.1.5/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=\ngithub.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=\ngithub.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=\ngithub.com/kelseyhightower/envconfig v1.4.0 h1:Im6hONhd3pLkfDFsbRgu68RDNkGF1r3dvMUtDTo2cv8=\ngithub.com/kelseyhightower/envconfig v1.4.0/go.mod h1:cccZRl6mQpaq41TPp5QxidR+Sa3axMbJDNb//FQX6Gg=\ngithub.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/klauspost/compress v1.18.0 h1:c/Cqfb0r+Yi+JtIEq73FWXVkRonBlf0CRNYc8Zttxdo=\ngithub.com/klauspost/compress v1.18.0/go.mod h1:2Pp+KzxcywXVXMr50+X0Q/Lsb43OQHYWRCY2AiWywWQ=\ngithub.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=\ngithub.com/klauspost/cpuid/v2 v2.2.7 h1:ZWSB3igEs+d0qvnxR/ZBzXVmxkgt8DdzP6m9pfuVLDM=\ngithub.com/klauspost/cpuid/v2 v2.2.7/go.mod h1:Lcz8mBdAVJIBVzewtcLocK12l3Y+JytZYpaMropDUws=\ngithub.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/kylelemons/godebug v1.1.0 h1:RPNrshWIDI6G2gRW9EHilWtl7Z6Sb1BR0xunSBf0SNc=\ngithub.com/kylelemons/godebug v1.1.0/go.mod h1:9/0rRGxNHcop5bhtWyNeEfOS8JIWk580+fNqagV/RAw=\ngithub.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=\ngithub.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=\ngithub.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=\ngithub.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=\ngithub.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0 h1:6E+4a0GO5zZEnZ81pIr0yLvtUWk2if982qA3F3QD6H4=\ngithub.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0/go.mod h1:zJYVVT2jmtg6P3p1VtQj7WsuWi/y4VnjVBn7F8KPB3I=\ngithub.com/magiconair/properties v1.8.10 h1:s31yESBquKXCV9a/ScB3ESkOjUYYv+X0rg8SYxI99mE=\ngithub.com/magiconair/properties v1.8.10/go.mod h1:Dhd985XPs7jluiymwWYZ0G4Z61jb3vdS329zhj2hYo0=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mdelapenya/tlscert v0.2.0 h1:7H81W6Z/4weDvZBNOfQte5GpIMo0lGYEeWbkGp5LJHI=\ngithub.com/mdelapenya/tlscert v0.2.0/go.mod h1:O4njj3ELLnJjGdkN7M/vIVCpZ+Cf0L6muqOG4tLSl8o=\ngithub.com/moby/docker-image-spec v1.3.1 h1:jMKff3w6PgbfSa69GfNg+zN/XLhfXJGnEx3Nl2EsFP0=\ngithub.com/moby/docker-image-spec v1.3.1/go.mod h1:eKmb5VW8vQEh/BAr2yvVNvuiJuY6UIocYsFu/DxxRpo=\ngithub.com/moby/go-archive v0.1.0 h1:Kk/5rdW/g+H8NHdJW2gsXyZ7UnzvJNOy6VKJqueWdcQ=\ngithub.com/moby/go-archive v0.1.0/go.mod h1:G9B+YoujNohJmrIYFBpSd54GTUB4lt9S+xVQvsJyFuo=\ngithub.com/moby/patternmatcher v0.6.0 h1:GmP9lR19aU5GqSSFko+5pRqHi+Ohk1O69aFiKkVGiPk=\ngithub.com/moby/patternmatcher v0.6.0/go.mod h1:hDPoyOpDY7OrrMDLaYoY3hf52gNCR/YOUYxkhApJIxc=\ngithub.com/moby/sys/atomicwriter v0.1.0 h1:kw5D/EqkBwsBFi0ss9v1VG3wIkVhzGvLklJ+w3A14Sw=\ngithub.com/moby/sys/atomicwriter v0.1.0/go.mod h1:Ul8oqv2ZMNHOceF643P6FKPXeCmYtlQMvpizfsSoaWs=\ngithub.com/moby/sys/sequential v0.6.0 h1:qrx7XFUd/5DxtqcoH1h438hF5TmOvzC/lspjy7zgvCU=\ngithub.com/moby/sys/sequential v0.6.0/go.mod h1:uyv8EUTrca5PnDsdMGXhZe6CCe8U/UiTWd+lL+7b/Ko=\ngithub.com/moby/sys/user v0.4.0 h1:jhcMKit7SA80hivmFJcbB1vqmw//wU61Zdui2eQXuMs=\ngithub.com/moby/sys/user v0.4.0/go.mod h1:bG+tYYYJgaMtRKgEmuueC0hJEAZWwtIbZTB+85uoHjs=\ngithub.com/moby/sys/userns v0.1.0 h1:tVLXkFOxVu9A64/yh59slHVv9ahO9UIev4JZusOLG/g=\ngithub.com/moby/sys/userns v0.1.0/go.mod h1:IHUYgu/kao6N8YZlp9Cf444ySSvCmDlmzUcYfDHOl28=\ngithub.com/moby/term v0.5.0 h1:xt8Q1nalod/v7BqbG21f8mQPqH+xAaC9C3N3wfWbVP0=\ngithub.com/moby/term v0.5.0/go.mod h1:8FzsFHVUBGZdbDsJw/ot+X+d5HLUbvklYLJ9uGfcI3Y=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=\ngithub.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=\ngithub.com/morikuni/aec v1.0.0 h1:nP9CBfwrvYnBRgY6qfDQkygYDmYwOilePFkwzv4dU8A=\ngithub.com/morikuni/aec v1.0.0/go.mod h1:BbKIizmSmc5MMPqRYbxO4ZU0S0+P200+tUnFx7PXmsc=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 h1:C3w9PqII01/Oq1c1nUAm88MOHcQC9l5mIlSMApZMrHA=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822/go.mod h1:+n7T8mK8HuQTcFwEeznm/DIxMOiR9yIdICNftLE1DvQ=\ngithub.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=\ngithub.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=\ngithub.com/opencontainers/image-spec v1.1.1 h1:y0fUlFfIZhPF1W537XOLg0/fcx6zcHCJwooC2xJA040=\ngithub.com/opencontainers/image-spec v1.1.1/go.mod h1:qpqAh3Dmcf36wStyyWU+kCeDgrGnAve2nCC8+7h8Q0M=\ngithub.com/pelletier/go-toml/v2 v2.2.2 h1:aYUidT7k73Pcl9nb2gScu7NSrKCSHIDE89b3+6Wq+LM=\ngithub.com/pelletier/go-toml/v2 v2.2.2/go.mod h1:1t835xjRzz80PqgE6HHgN2JOsmgYu/h4qDAS4n929Rs=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c h1:ncq/mPwQF4JjgDlrVEn3C11VoGHZN7m8qihwgMEtzYw=\ngithub.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c/go.mod h1:OmDBASR4679mdNQnz2pUhc2G8CO2JrUAVFDRBDP/hJE=\ngithub.com/prometheus/client_golang v1.20.5 h1:cxppBPuYhUnsO6yo/aoRol4L7q7UFfdm+bR9r+8l63Y=\ngithub.com/prometheus/client_golang v1.20.5/go.mod h1:PIEt8X02hGcP8JWbeHyeZ53Y/jReSnHgO035n//V5WE=\ngithub.com/prometheus/client_model v0.6.1 h1:ZKSh/rekM+n3CeS952MLRAdFwIKqeY8b62p8ais2e9E=\ngithub.com/prometheus/client_model v0.6.1/go.mod h1:OrxVMOVHjw3lKMa8+x6HeMGkHMQyHDk9E3jmP2AmGiY=\ngithub.com/prometheus/common v0.55.0 h1:KEi6DK7lXW/m7Ig5i47x0vRzuBsHuvJdi5ee6Y3G1dc=\ngithub.com/prometheus/common v0.55.0/go.mod h1:2SECS4xJG1kd8XF9IcM1gMX6510RAEL65zxzNImwdc8=\ngithub.com/prometheus/procfs v0.15.1 h1:YagwOFzUgYfKKHX6Dr+sHT7km/hxC76UB0learggepc=\ngithub.com/prometheus/procfs v0.15.1/go.mod h1:fB45yRUv8NstnjriLhBQLuOUt+WW4BsoGhij/e3PBqk=\ngithub.com/rogpeppe/go-internal v1.14.1 h1:UQB4HGPB6osV0SQTLymcB4TgvyWu6ZyliaW0tI/otEQ=\ngithub.com/rogpeppe/go-internal v1.14.1/go.mod h1:MaRKkUm5W0goXpeCfT7UZI6fk/L7L7so1lCWt35ZSgc=\ngithub.com/shirou/gopsutil/v4 v4.25.5 h1:rtd9piuSMGeU8g1RMXjZs9y9luK5BwtnG7dZaQUJAsc=\ngithub.com/shirou/gopsutil/v4 v4.25.5/go.mod h1:PfybzyydfZcN+JMMjkF6Zb8Mq1A/VcogFFg7hj50W9c=\ngithub.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=\ngithub.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=\ngithub.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/testcontainers/testcontainers-go v0.38.0 h1:d7uEapLcv2P8AvH8ahLqDMMxda2W9gQN1nRbHS28HBw=\ngithub.com/testcontainers/testcontainers-go v0.38.0/go.mod h1:C52c9MoHpWO+C4aqmgSU+hxlR5jlEayWtgYrb8Pzz1w=\ngithub.com/testcontainers/testcontainers-go/modules/postgres v0.38.0 h1:KFdx9A0yF94K70T6ibSuvgkQQeX1xKlZVF3hEagXEtY=\ngithub.com/testcontainers/testcontainers-go/modules/postgres v0.38.0/go.mod h1:T/QRECND6N6tAKMxF1Za+G2tpwnGEHcODzHRsgIpw9M=\ngithub.com/tklauser/go-sysconf v0.3.12 h1:0QaGUFOdQaIVdPgfITYzaTegZvdCjmYO52cSFAEVmqU=\ngithub.com/tklauser/go-sysconf v0.3.12/go.mod h1:Ho14jnntGE1fpdOqQEEaiKRpvIavV0hSfmBq8nJbHYI=\ngithub.com/tklauser/numcpus v0.6.1 h1:ng9scYS7az0Bk4OZLvrNXNSAO2Pxr1XXRAPyjhIx+Fk=\ngithub.com/tklauser/numcpus v0.6.1/go.mod h1:1XfjsgE2zo8GVw7POkMbHENHzVg3GzmoZ9fESEdAacY=\ngithub.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=\ngithub.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=\ngithub.com/ugorji/go/codec v1.2.12 h1:9LC83zGrHhuUA9l16C9AHXAqEV/2wBQ4nkvumAE65EE=\ngithub.com/ugorji/go/codec v1.2.12/go.mod h1:UNopzCgEMSXjBc6AOMqYvWC1ktqTAfzJZUZgYf6w6lg=\ngithub.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yusufpapurcu/wmi v1.2.4 h1:zFUKzehAFReQwLys1b/iSMl+JQGSCSjtVqQn9bBrPo0=\ngithub.com/yusufpapurcu/wmi v1.2.4/go.mod h1:SBZ9tNy3G9/m5Oi98Zks0QjeHVDvuK0qfxQmPyzfmi0=\ngo.opentelemetry.io/auto/sdk v1.1.0 h1:cH53jehLUN6UFLY71z+NDOiNJqDdPRaXzTel0sJySYA=\ngo.opentelemetry.io/auto/sdk v1.1.0/go.mod h1:3wSPjt5PWp2RhlCcmmOial7AvC4DQqZb7a7wCow3W8A=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0 h1:jq9TW8u3so/bN+JPT166wjOI6/vQPF6Xe7nMNIltagk=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0/go.mod h1:p8pYQP+m5XfbZm9fxtSKAbM6oIllS7s2AfxrChvc7iw=\ngo.opentelemetry.io/otel v1.35.0 h1:xKWKPxrxB6OtMCbmMY021CqC45J+3Onta9MqjhnusiQ=\ngo.opentelemetry.io/otel v1.35.0/go.mod h1:UEqy8Zp11hpkUrL73gSlELM0DupHoiq72dR+Zqel/+Y=\ngo.opentelemetry.io/otel/exporters/otlp/otlptrace v1.19.0 h1:Mne5On7VWdx7omSrSSZvM4Kw7cS7NQkOOmLcgscI51U=\ngo.opentelemetry.io/otel/exporters/otlp/otlptrace v1.19.0/go.mod h1:IPtUMKL4O3tH5y+iXVyAXqpAwMuzC1IrxVS81rummfE=\ngo.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.19.0 h1:IeMeyr1aBvBiPVYihXIaeIZba6b8E1bYp7lbdxK8CQg=\ngo.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.19.0/go.mod h1:oVdCUtjq9MK9BlS7TtucsQwUcXcymNiEDjgDD2jMtZU=\ngo.opentelemetry.io/otel/metric v1.35.0 h1:0znxYu2SNyuMSQT4Y9WDWej0VpcsxkuklLa4/siN90M=\ngo.opentelemetry.io/otel/metric v1.35.0/go.mod h1:nKVFgxBZ2fReX6IlyW28MgZojkoAkJGaE8CpgeAU3oE=\ngo.opentelemetry.io/otel/sdk v1.35.0 h1:iPctf8iprVySXSKJffSS79eOjl9pvxV9ZqOWT0QejKY=\ngo.opentelemetry.io/otel/sdk v1.35.0/go.mod h1:+ga1bZliga3DxJ3CQGg3updiaAJoNECOgJREo9KHGQg=\ngo.opentelemetry.io/otel/trace v1.35.0 h1:dPpEfJu1sDIqruz7BHFG3c7528f6ddfSWfFDVt/xgMs=\ngo.opentelemetry.io/otel/trace v1.35.0/go.mod h1:WUk7DtFp1Aw2MkvqGdwiXYDZZNvA/1J8o6xRXLrIkyc=\ngo.opentelemetry.io/proto/otlp v1.0.0 h1:T0TX0tmXU8a3CbNXzEKGeU5mIVOdf0oykP+u2lIVU/I=\ngo.opentelemetry.io/proto/otlp v1.0.0/go.mod h1:Sy6pihPLfYHkr3NkUbEhGHFhINUSI/v80hjKIs5JXpM=\ngolang.org/x/arch v0.0.0-20210923205945-b76863e36670/go.mod h1:5om86z9Hs0C8fWVUuoMHwpExlXzs5Tkyp9hOrfG7pp8=\ngolang.org/x/arch v0.8.0 h1:3wRIsP3pM4yUptoR96otTUOXI367OS0+c9eeRi9doIc=\ngolang.org/x/arch v0.8.0/go.mod h1:FEVrYAQjsQXMVJ1nsMoVVXPZg6p2JE2mx8psSWTDQys=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.37.0 h1:kJNSjF/Xp7kU0iB2Z+9viTPMW4EqqsrywMXLJOOsXSE=\ngolang.org/x/crypto v0.37.0/go.mod h1:vg+k43peMZ0pUMhYmVAWysMK35e6ioLh3wB8ZCAfbVc=\ngolang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.38.0 h1:vRMAPTMaeGqVhG5QyLJHqNDwecKTomGeqbnfZyKlBI8=\ngolang.org/x/net v0.38.0/go.mod h1:ivrbrMbzFq5J41QOQh0siUuly180yBYtLp+CKbEaFx8=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.15.0 h1:KWH3jNZsfyT6xfAfKiz6MRNmd46ByHDYaZ7KSkCtdW8=\ngolang.org/x/sync v0.15.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190916202348-b4ddaad3f8a3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201204225414-ed752295db88/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210616094352-59db8d763f22/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.11.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.32.0 h1:s77OFDvIQeibCmezSnk/q6iAfkdiQaJi4VzroCFrN20=\ngolang.org/x/sys v0.32.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\ngolang.org/x/term v0.31.0 h1:erwDkOK1Msy6offm1mOgvspSkslFnIGsFnxOKoufg3o=\ngolang.org/x/term v0.31.0/go.mod h1:R4BeIy7D95HzImkxGkTW1UQTtP54tio2RyHz7PwK0aw=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.26.0 h1:P42AVeLghgTYr4+xUnTRKDMqpar+PtX7KWuNQL21L8M=\ngolang.org/x/text v0.26.0/go.mod h1:QK15LZJUUQVJxhz7wXgxSy/CJaTFjd0G+YLonydOVQA=\ngolang.org/x/time v0.12.0 h1:ScB/8o8olJvc+CQPWrK3fPZNfh7qgwCrY0zJmoEQLSE=\ngolang.org/x/time v0.12.0/go.mod h1:CDIdPxbZBQxdj6cxyCIdrNogrJKMJ7pr37NYpMcMDSg=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20250603155806-513f23925822 h1:oWVWY3NzT7KJppx2UKhKmzPq4SRe0LdCijVRwvGeikY=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20250603155806-513f23925822/go.mod h1:h3c4v36UTKzUiuaOKQ6gr3S+0hovBtUrXzTG/i3+XEc=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20250603155806-513f23925822 h1:fc6jSaCT0vBduLYZHYrBBNY4dsWuvgyff9noRNDdBeE=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20250603155806-513f23925822/go.mod h1:qQ0YXyHHx3XkvlzUtpXDkS29lDSafHMZBAZDc03LQ3A=\ngoogle.golang.org/grpc v1.73.0 h1:VIWSmpI2MegBtTuFt5/JWy2oXxtjJ/e89Z70ImfD2ok=\ngoogle.golang.org/grpc v1.73.0/go.mod h1:50sbHOUqWoCQGI8V2HQLJM0B+LMlIUjNSZmow7EVBQc=\ngoogle.golang.org/protobuf v1.36.6 h1:z1NpPI8ku2WgiWnf+t9wTPsn6eP1L7ksHUlkfLvd9xY=\ngoogle.golang.org/protobuf v1.36.6/go.mod h1:jduwjTPXsFjZGTmRluh+L6NjiWu7pchiJ2/5YcXBHnY=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngorm.io/driver/postgres v1.5.4 h1:Iyrp9Meh3GmbSuyIAGyjkN+n9K+GHX9b9MqsTL4EJCo=\ngorm.io/driver/postgres v1.5.4/go.mod h1:Bgo89+h0CRcdA33Y6frlaHHVuTdOf87pmyzwW9C/BH0=\ngorm.io/gorm v1.25.5 h1:zR9lOiiYf09VNh5Q1gphfyia1JpiClIWG9hQaxB/mls=\ngorm.io/gorm v1.25.5/go.mod h1:hbnx/Oo0ChWMn1BIhpy1oYozzpM15i4YPuHDmfYtwg8=\ngotest.tools/v3 v3.5.2 h1:7koQfIKdy+I8UTetycgUqXWSDwpgv193Ka+qRsmBY8Q=\ngotest.tools/v3 v3.5.2/go.mod h1:LtdLGcnqToBH83WByAAi/wiwSFCArdFIUV/xxN4pcjA=\nnullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=\nrsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=\n",
      "size": 27264,
      "hash": "ecdc1f1bd3b70ec0ddd51ea812c8bb49b073a3cc7fdc0e7951e25eeddb4484b0"
    },
    {
      "path": "internal/auth/service/jwt.go",
      "template": true,
      "content": "package service\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v5\"\n)\n\nvar (\n\tErrInvalidToken = errors.New(\"invalid token\")\n\tErrExpiredToken = errors.New(\"token expired\")\n)\n\ntype Claims struct {\n\tServiceName string `json:\"service_name\"`\n\tServiceID   string `json:\"service_id\"`\n\tVersion     string `json:\"version\"`\n\tEnvironment string `json:\"environment\"`\n\tjwt.RegisteredClaims\n}\n\ntype JWTService interface {\n\tGenerateServiceToken(serviceName, serviceID, version, environment string) (string, error)\n\tValidateToken(tokenString string) (*Claims, error)\n}\n\ntype jwtService struct {\n\tsecret     []byte\n\texpiration time.Duration\n}\n\nfunc NewJWTService(secret string, expiration time.Duration) JWTService {\n\treturn \u0026jwtService{\n\t\tsecret:     []byte(secret),\n\t\texpiration: expiration,\n\t}\n}\n\nfunc (s *jwtService) GenerateServiceToken(serviceName, serviceID, version, environment string) (string, error) {\n\tnow := time.Now()\n\tclaims := \u0026Claims{\n\t\tServiceName: serviceName,\n\t\tServiceID:   serviceID,\n\t\tVersion:     version,\n\t\tEnvironment: environment,\n\t\tRegisteredClaims: jwt.RegisteredClaims{\n\t\t\tExpiresAt: jwt.NewNumericDate(now.Add(s.expiration)),\n\t\t\tIssuedAt:  jwt.NewNumericDate(now),\n\t\t\tNotBefore: jwt.NewNumericDate(now),\n\t\t\tSubject:   serviceName,\n\t\t\tIssuer:    serviceID,\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\treturn token.SignedString(s.secret)\n}\n\nfunc (s *jwtService) ValidateToken(tokenString string) (*Claims, error) {\n\ttoken, err := jwt.ParseWithClaims(tokenString, \u0026Claims{}, func(token *jwt.Token) (interface{}, error) {\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\treturn nil, ErrInvalidToken\n\t\t}\n\t\treturn s.secret, nil\n\t})\n\tif err != nil {\n\t\tif errors.Is(err, jwt.ErrTokenExpired) {\n\t\t\treturn nil, ErrExpiredToken\n\t\t}\n\t\treturn nil, ErrInvalidToken\n\t}\n\n\tif claims, ok := token.Claims.(*Claims); ok \u0026\u0026 token.Valid {\n\t\treturn claims, nil\n\t}\n\n\treturn nil, ErrInvalidToken\n}\n",
      "size": 1935,
      "hash": "65d6eaed238724ec16c5dd3227bb36c18bd2d72dc21b34abf15d83b4bc1402ac",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/client/circuitbreaker.go",
      "template": true,
      "content": "package client\n\nimport (\n\t\"errors\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar (\n\tErrCircuitOpen     = errors.New(\"circuit breaker is open\")\n\tErrTooManyRequests = errors.New(\"too many requests when circuit breaker is half-open\")\n)\n\ntype State int\n\nconst (\n\tStateClosed State = iota\n\tStateHalfOpen\n\tStateOpen\n)\n\nfunc (s State) String() string {\n\tswitch s {\n\tcase StateClosed:\n\t\treturn \"closed\"\n\tcase StateHalfOpen:\n\t\treturn \"half-open\"\n\tcase StateOpen:\n\t\treturn \"open\"\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}\n\ntype Counts struct {\n\tRequests             uint32\n\tTotalSuccesses       uint32\n\tTotalFailures        uint32\n\tConsecutiveSuccesses uint32\n\tConsecutiveFailures  uint32\n}\n\nfunc (c *Counts) onRequest() {\n\tc.Requests++\n}\n\nfunc (c *Counts) onSuccess() {\n\tc.TotalSuccesses++\n\tc.ConsecutiveSuccesses++\n\tc.ConsecutiveFailures = 0\n}\n\nfunc (c *Counts) onFailure() {\n\tc.TotalFailures++\n\tc.ConsecutiveFailures++\n\tc.ConsecutiveSuccesses = 0\n}\n\nfunc (c *Counts) clear() {\n\tc.Requests = 0\n\tc.TotalSuccesses = 0\n\tc.TotalFailures = 0\n\tc.ConsecutiveSuccesses = 0\n\tc.ConsecutiveFailures = 0\n}\n\ntype Settings struct {\n\tName          string\n\tMaxRequests   uint32\n\tInterval      time.Duration\n\tTimeout       time.Duration\n\tReadyToTrip   func(counts Counts) bool\n\tOnStateChange func(name string, from State, to State)\n\tIsSuccessful  func(err error) bool\n}\n\ntype CircuitBreaker struct {\n\tname          string\n\tmaxRequests   uint32\n\tinterval      time.Duration\n\ttimeout       time.Duration\n\treadyToTrip   func(counts Counts) bool\n\tisSuccessful  func(err error) bool\n\tonStateChange func(name string, from State, to State)\n\n\tmutex      sync.Mutex\n\tstate      State\n\tgeneration uint64\n\tcounts     Counts\n\texpiry     time.Time\n}\n\nfunc NewCircuitBreaker(st Settings) *CircuitBreaker {\n\tcb := \u0026CircuitBreaker{\n\t\tname:          st.Name,\n\t\tmaxRequests:   st.MaxRequests,\n\t\tinterval:      st.Interval,\n\t\ttimeout:       st.Timeout,\n\t\treadyToTrip:   st.ReadyToTrip,\n\t\tisSuccessful:  st.IsSuccessful,\n\t\tonStateChange: st.OnStateChange,\n\t}\n\n\tif cb.maxRequests == 0 {\n\t\tcb.maxRequests = 1\n\t}\n\n\tif cb.interval \u003c= 0 {\n\t\tcb.interval = time.Duration(0)\n\t}\n\n\tif cb.timeout \u003c= 0 {\n\t\tcb.timeout = 60 * time.Second\n\t}\n\n\tif cb.readyToTrip == nil {\n\t\tcb.readyToTrip = func(counts Counts) bool {\n\t\t\treturn counts.ConsecutiveFailures \u003e 5\n\t\t}\n\t}\n\n\tif cb.isSuccessful == nil {\n\t\tcb.isSuccessful = func(err error) bool {\n\t\t\treturn err == nil\n\t\t}\n\t}\n\n\tcb.setState(StateClosed)\n\n\treturn cb\n}\n\nfunc (cb *CircuitBreaker) Name() string {\n\treturn cb.name\n}\n\nfunc (cb *CircuitBreaker) State() State {\n\tcb.mutex.Lock()\n\tdefer cb.mutex.Unlock()\n\n\tnow := time.Now()\n\tstate, _ := cb.currentState(now)\n\treturn state\n}\n\nfunc (cb *CircuitBreaker) Counts() Counts {\n\tcb.mutex.Lock()\n\tdefer cb.mutex.Unlock()\n\treturn cb.counts\n}\n\nfunc (cb *CircuitBreaker) Execute(req func() (interface{}, error)) (interface{}, error) {\n\tgeneration, err := cb.beforeRequest()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer func() {\n\t\te := recover()\n\t\tif e != nil {\n\t\t\tcb.afterRequest(generation, false)\n\t\t\tpanic(e)\n\t\t}\n\t}()\n\n\tresult, err := req()\n\tcb.afterRequest(generation, cb.isSuccessful(err))\n\treturn result, err\n}\n\nfunc (cb *CircuitBreaker) beforeRequest() (uint64, error) {\n\tcb.mutex.Lock()\n\tdefer cb.mutex.Unlock()\n\n\tnow := time.Now()\n\tstate, generation := cb.currentState(now)\n\n\tif state == StateOpen {\n\t\treturn generation, ErrCircuitOpen\n\t} else if state == StateHalfOpen \u0026\u0026 cb.counts.Requests \u003e= cb.maxRequests {\n\t\treturn generation, ErrTooManyRequests\n\t}\n\n\tcb.counts.onRequest()\n\treturn generation, nil\n}\n\nfunc (cb *CircuitBreaker) afterRequest(before uint64, success bool) {\n\tcb.mutex.Lock()\n\tdefer cb.mutex.Unlock()\n\n\tnow := time.Now()\n\tstate, generation := cb.currentState(now)\n\tif generation != before {\n\t\treturn\n\t}\n\n\tif success {\n\t\tcb.onSuccess(state)\n\t} else {\n\t\tcb.onFailure(state)\n\t}\n}\n\nfunc (cb *CircuitBreaker) onSuccess(state State) {\n\tcb.counts.onSuccess()\n\n\tif state == StateHalfOpen {\n\t\tcb.setState(StateClosed)\n\t}\n}\n\nfunc (cb *CircuitBreaker) onFailure(state State) {\n\tcb.counts.onFailure()\n\n\tswitch state {\n\tcase StateClosed:\n\t\tif cb.readyToTrip(cb.counts) {\n\t\t\tcb.setState(StateOpen)\n\t\t}\n\tcase StateHalfOpen:\n\t\tcb.setState(StateOpen)\n\t}\n}\n\nfunc (cb *CircuitBreaker) currentState(now time.Time) (State, uint64) {\n\tswitch cb.state {\n\tcase StateClosed:\n\t\tif !cb.expiry.IsZero() \u0026\u0026 cb.expiry.Before(now) {\n\t\t\tcb.toNewGeneration(now)\n\t\t}\n\tcase StateOpen:\n\t\tif cb.expiry.Before(now) {\n\t\t\tcb.setState(StateHalfOpen)\n\t\t}\n\t}\n\treturn cb.state, cb.generation\n}\n\nfunc (cb *CircuitBreaker) setState(state State) {\n\tif cb.state == state {\n\t\treturn\n\t}\n\n\tprev := cb.state\n\tcb.state = state\n\n\tnow := time.Now()\n\tcb.toNewGeneration(now)\n\n\tif cb.onStateChange != nil {\n\t\tcb.onStateChange(cb.name, prev, state)\n\t}\n}\n\nfunc (cb *CircuitBreaker) toNewGeneration(now time.Time) {\n\tcb.generation++\n\tcb.counts.clear()\n\n\tvar zero time.Time\n\tswitch cb.state {\n\tcase StateClosed:\n\t\tif cb.interval == 0 {\n\t\t\tcb.expiry = zero\n\t\t} else {\n\t\t\tcb.expiry = now.Add(cb.interval)\n\t\t}\n\tcase StateOpen:\n\t\tcb.expiry = now.Add(cb.timeout)\n\tdefault: // StateHalfOpen\n\t\tcb.expiry = zero\n\t}\n}\n",
      "size": 5070,
      "hash": "90cd7026543ec975e9d326aa67a7742314bbcbce1c677343c22f2a3c09248f9e",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/client/http.go",
      "template": true,
      "content": "package client\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"log/slog\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/acheevo/api-template/internal/auth/service\"\n\t\"github.com/google/uuid\"\n)\n\ntype HTTPClient struct {\n\tclient         *http.Client\n\tcircuitBreaker *CircuitBreaker\n\tjwtService     service.JWTService\n\tserviceName    string\n\tserviceID      string\n\tversion        string\n\tenvironment    string\n\tlogger         *slog.Logger\n}\n\ntype HTTPClientConfig struct {\n\tServiceName string\n\tServiceID   string\n\tVersion     string\n\tEnvironment string\n\tTimeout     time.Duration\n\tJWTService  service.JWTService\n\tLogger      *slog.Logger\n}\n\nfunc NewHTTPClient(config HTTPClientConfig) *HTTPClient {\n\tif config.Timeout == 0 {\n\t\tconfig.Timeout = 30 * time.Second\n\t}\n\n\thttpClient := \u0026http.Client{\n\t\tTimeout: config.Timeout,\n\t}\n\n\t// Circuit breaker settings\n\tcbSettings := Settings{\n\t\tName:        fmt.Sprintf(\"%s-circuit-breaker\", config.ServiceName),\n\t\tMaxRequests: 3,\n\t\tInterval:    10 * time.Second,\n\t\tTimeout:     60 * time.Second,\n\t\tReadyToTrip: func(counts Counts) bool {\n\t\t\treturn counts.ConsecutiveFailures \u003e= 3\n\t\t},\n\t\tOnStateChange: func(name string, from State, to State) {\n\t\t\tif config.Logger != nil {\n\t\t\t\tconfig.Logger.Info(\"circuit breaker state changed\",\n\t\t\t\t\t\"name\", name,\n\t\t\t\t\t\"from\", from.String(),\n\t\t\t\t\t\"to\", to.String())\n\t\t\t}\n\t\t},\n\t\tIsSuccessful: func(err error) bool {\n\t\t\treturn err == nil\n\t\t},\n\t}\n\n\treturn \u0026HTTPClient{\n\t\tclient:         httpClient,\n\t\tcircuitBreaker: NewCircuitBreaker(cbSettings),\n\t\tjwtService:     config.JWTService,\n\t\tserviceName:    config.ServiceName,\n\t\tserviceID:      config.ServiceID,\n\t\tversion:        config.Version,\n\t\tenvironment:    config.Environment,\n\t\tlogger:         config.Logger,\n\t}\n}\n\nfunc (c *HTTPClient) Do(ctx context.Context, method, url string, body interface{},\n\theaders map[string]string,\n) (*http.Response, error) {\n\tresult, err := c.circuitBreaker.Execute(func() (interface{}, error) {\n\t\treturn c.doRequest(ctx, method, url, body, headers)\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse, ok := result.(*http.Response)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"unexpected result type\")\n\t}\n\treturn response, nil\n}\n\nfunc (c *HTTPClient) doRequest(ctx context.Context, method, url string, body interface{},\n\theaders map[string]string,\n) (*http.Response, error) {\n\tvar bodyReader io.Reader\n\n\tif body != nil {\n\t\tbodyBytes, err := json.Marshal(body)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to marshal request body: %w\", err)\n\t\t}\n\t\tbodyReader = bytes.NewReader(bodyBytes)\n\t}\n\n\treq, err := http.NewRequestWithContext(ctx, method, url, bodyReader)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\n\t// Add service-to-service JWT token\n\ttoken, err := c.jwtService.GenerateServiceToken(c.serviceName, c.serviceID, c.version, c.environment)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to generate service token: %w\", err)\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer \"+token)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"User-Agent\", fmt.Sprintf(\"%s/%s\", c.serviceName, c.version))\n\n\t// Add X-Request-ID for tracing\n\tif requestID := ctx.Value(\"request_id\"); requestID != nil {\n\t\tif id, ok := requestID.(string); ok {\n\t\t\treq.Header.Set(\"X-Request-ID\", id)\n\t\t}\n\t} else {\n\t\treq.Header.Set(\"X-Request-ID\", uuid.New().String())\n\t}\n\n\t// Add custom headers\n\tfor key, value := range headers {\n\t\treq.Header.Set(key, value)\n\t}\n\n\tstart := time.Now()\n\tresp, err := c.client.Do(req)\n\tduration := time.Since(start)\n\n\t// Log the request\n\tif c.logger != nil {\n\t\tlogFields := []interface{}{\n\t\t\t\"method\", method,\n\t\t\t\"url\", url,\n\t\t\t\"duration\", duration,\n\t\t\t\"circuit_breaker_state\", c.circuitBreaker.State().String(),\n\t\t}\n\n\t\tif err != nil {\n\t\t\tlogFields = append(logFields, \"error\", err)\n\t\t\tc.logger.Error(\"HTTP request failed\", logFields...)\n\t\t} else {\n\t\t\tlogFields = append(logFields, \"status\", resp.StatusCode)\n\t\t\tif resp.StatusCode \u003e= 400 {\n\t\t\t\tc.logger.Warn(\"HTTP request returned error status\", logFields...)\n\t\t\t} else {\n\t\t\t\tc.logger.Debug(\"HTTP request completed\", logFields...)\n\t\t\t}\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"request failed: %w\", err)\n\t}\n\n\t// Consider 5xx status codes as failures for circuit breaker\n\tif resp.StatusCode \u003e= 500 {\n\t\treturn resp, fmt.Errorf(\"server error: %d\", resp.StatusCode)\n\t}\n\n\treturn resp, nil\n}\n\nfunc (c *HTTPClient) Get(ctx context.Context, url string, headers map[string]string) (*http.Response, error) {\n\treturn c.Do(ctx, http.MethodGet, url, nil, headers)\n}\n\nfunc (c *HTTPClient) Post(ctx context.Context, url string, body interface{},\n\theaders map[string]string,\n) (*http.Response, error) {\n\treturn c.Do(ctx, http.MethodPost, url, body, headers)\n}\n\nfunc (c *HTTPClient) Put(ctx context.Context, url string, body interface{},\n\theaders map[string]string,\n) (*http.Response, error) {\n\treturn c.Do(ctx, http.MethodPut, url, body, headers)\n}\n\nfunc (c *HTTPClient) Delete(ctx context.Context, url string, headers map[string]string) (*http.Response, error) {\n\treturn c.Do(ctx, http.MethodDelete, url, nil, headers)\n}\n\nfunc (c *HTTPClient) CircuitBreakerState() State {\n\treturn c.circuitBreaker.State()\n}\n\nfunc (c *HTTPClient) CircuitBreakerCounts() Counts {\n\treturn c.circuitBreaker.Counts()\n}\n",
      "size": 5248,
      "hash": "9c7dd16cff5d62b8b4176efbd4e82b3dc288ab9273cc7f1a448f779adaedcda4",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/client/tests/circuitbreaker_test.go",
      "template": true,
      "content": "package tests\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/acheevo/api-template/internal/client\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestCircuitBreaker(t *testing.T) {\n\tsettings := client.Settings{\n\t\tName:        \"test-circuit-breaker\",\n\t\tMaxRequests: 3,\n\t\tInterval:    100 * time.Millisecond,\n\t\tTimeout:     200 * time.Millisecond,\n\t\tReadyToTrip: func(counts client.Counts) bool {\n\t\t\treturn counts.ConsecutiveFailures \u003e= 2\n\t\t},\n\t}\n\n\tcb := client.NewCircuitBreaker(settings)\n\n\t// Test initial state is closed\n\tassert.Equal(t, client.StateClosed, cb.State())\n\n\t// Test successful requests\n\tresult, err := cb.Execute(func() (interface{}, error) {\n\t\treturn \"success\", nil\n\t})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"success\", result)\n\tassert.Equal(t, client.StateClosed, cb.State())\n\n\t// Test failures to trigger open state\n\tfor i := 0; i \u003c 2; i++ {\n\t\t_, err := cb.Execute(func() (interface{}, error) {\n\t\t\treturn nil, errors.New(\"failure\")\n\t\t})\n\t\tassert.Error(t, err)\n\t}\n\n\t// Circuit should now be open\n\tassert.Equal(t, client.StateOpen, cb.State())\n\n\t// Test requests are rejected when open\n\t_, err = cb.Execute(func() (interface{}, error) {\n\t\treturn \"should not execute\", nil\n\t})\n\tassert.Error(t, err)\n\tassert.Equal(t, client.ErrCircuitOpen, err)\n\n\t// Wait for timeout to transition to half-open\n\ttime.Sleep(250 * time.Millisecond)\n\tassert.Equal(t, client.StateHalfOpen, cb.State())\n\n\t// Test successful request closes the circuit\n\tresult, err = cb.Execute(func() (interface{}, error) {\n\t\treturn \"success after recovery\", nil\n\t})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"success after recovery\", result)\n\tassert.Equal(t, client.StateClosed, cb.State())\n}\n\nfunc TestCircuitBreakerCounts(t *testing.T) {\n\tsettings := client.Settings{\n\t\tName:        \"test-counts\",\n\t\tMaxRequests: 5,\n\t\tInterval:    time.Second,\n\t\tTimeout:     time.Second,\n\t}\n\n\tcb := client.NewCircuitBreaker(settings)\n\n\t// Execute some successful requests\n\tfor i := 0; i \u003c 3; i++ {\n\t\tcb.Execute(func() (interface{}, error) {\n\t\t\treturn \"success\", nil\n\t\t})\n\t}\n\n\tcounts := cb.Counts()\n\tassert.Equal(t, uint32(3), counts.Requests)\n\tassert.Equal(t, uint32(3), counts.TotalSuccesses)\n\tassert.Equal(t, uint32(0), counts.TotalFailures)\n\tassert.Equal(t, uint32(3), counts.ConsecutiveSuccesses)\n\n\t// Execute a failure\n\tcb.Execute(func() (interface{}, error) {\n\t\treturn nil, errors.New(\"failure\")\n\t})\n\n\tcounts = cb.Counts()\n\tassert.Equal(t, uint32(4), counts.Requests)\n\tassert.Equal(t, uint32(3), counts.TotalSuccesses)\n\tassert.Equal(t, uint32(1), counts.TotalFailures)\n\tassert.Equal(t, uint32(0), counts.ConsecutiveSuccesses)\n\tassert.Equal(t, uint32(1), counts.ConsecutiveFailures)\n}\n",
      "size": 2658,
      "hash": "d5514fb0595140eb0dde15a1e75a1fc32f515fdf640cc8d381e5ab30f0c723e3",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/health/domain/types.go",
      "template": true,
      "content": "package domain\n\nimport \"time\"\n\ntype Status string\n\nconst (\n\tStatusHealthy   Status = \"healthy\"\n\tStatusUnhealthy Status = \"unhealthy\"\n\tStatusDegraded  Status = \"degraded\"\n)\n\ntype HealthResponse struct {\n\tStatus    Status               `json:\"status\"`\n\tService   ServiceInfo          `json:\"service\"`\n\tTimestamp time.Time            `json:\"timestamp\"`\n\tUptime    time.Duration        `json:\"uptime\"`\n\tChecks    map[string]CheckInfo `json:\"checks,omitempty\"`\n}\n\ntype ServiceInfo struct {\n\tName        string `json:\"name\"`\n\tVersion     string `json:\"version\"`\n\tEnvironment string `json:\"environment\"`\n\tInstance    string `json:\"instance\"`\n}\n\ntype CheckInfo struct {\n\tStatus    Status        `json:\"status\"`\n\tMessage   string        `json:\"message,omitempty\"`\n\tDuration  time.Duration `json:\"duration\"`\n\tTimestamp time.Time     `json:\"timestamp\"`\n}\n\ntype ReadinessResponse struct {\n\tStatus    Status               `json:\"status\"`\n\tService   ServiceInfo          `json:\"service\"`\n\tTimestamp time.Time            `json:\"timestamp\"`\n\tChecks    map[string]CheckInfo `json:\"checks\"`\n}\n\ntype Check interface {\n\tName() string\n\tCheck() CheckInfo\n}\n",
      "size": 1135,
      "hash": "0628a54bb27983ba3c7e555b80dd9257bcf13677ecd079b38610a478ec046e54",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/health/service/health.go",
      "template": true,
      "content": "package service\n\nimport (\n\t\"context\"\n\t\"log/slog\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/acheevo/api-template/internal/health/domain\"\n\t\"github.com/acheevo/api-template/internal/shared/config\"\n\t\"github.com/acheevo/api-template/internal/shared/database\"\n)\n\ntype HealthService interface {\n\tGetHealth() *domain.HealthResponse\n\tGetReadiness() *domain.ReadinessResponse\n\tAddCheck(check domain.Check)\n\tRemoveCheck(name string)\n}\n\ntype healthService struct {\n\tcfg       *config.Config\n\tdb        *database.Database\n\tlogger    *slog.Logger\n\tstartTime time.Time\n\tchecks    map[string]domain.Check\n\tmu        sync.RWMutex\n}\n\nfunc NewHealthService(cfg *config.Config, db *database.Database, logger *slog.Logger) HealthService {\n\tservice := \u0026healthService{\n\t\tcfg:       cfg,\n\t\tdb:        db,\n\t\tlogger:    logger,\n\t\tstartTime: time.Now(),\n\t\tchecks:    make(map[string]domain.Check),\n\t}\n\n\t// Add default database check with caching\n\tif db != nil {\n\t\tservice.AddCheck(NewCachedDatabaseCheck(db, 5*time.Minute))\n\t}\n\n\treturn service\n}\n\nfunc (s *healthService) GetHealth() *domain.HealthResponse {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\n\thealth := \u0026domain.HealthResponse{\n\t\tStatus:    domain.StatusHealthy,\n\t\tService:   s.getServiceInfo(),\n\t\tTimestamp: time.Now(),\n\t\tUptime:    time.Since(s.startTime),\n\t\tChecks:    make(map[string]domain.CheckInfo),\n\t}\n\n\t// Run all health checks (cached for performance)\n\tfor name, check := range s.checks {\n\t\tvar checkInfo domain.CheckInfo\n\t\tif cachedCheck, ok := check.(CachedCheck); ok {\n\t\t\tcheckInfo = cachedCheck.CachedCheck()\n\t\t} else {\n\t\t\tcheckInfo = check.Check()\n\t\t}\n\t\thealth.Checks[name] = checkInfo\n\n\t\tif checkInfo.Status != domain.StatusHealthy {\n\t\t\thealth.Status = domain.StatusDegraded\n\t\t}\n\t}\n\n\treturn health\n}\n\nfunc (s *healthService) GetReadiness() *domain.ReadinessResponse {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\n\treadiness := \u0026domain.ReadinessResponse{\n\t\tStatus:    domain.StatusHealthy,\n\t\tService:   s.getServiceInfo(),\n\t\tTimestamp: time.Now(),\n\t\tChecks:    make(map[string]domain.CheckInfo),\n\t}\n\n\t// Run all readiness checks (more strict than health, always fresh)\n\tfor name, check := range s.checks {\n\t\tcheckInfo := check.Check() // Always fresh check for readiness\n\t\treadiness.Checks[name] = checkInfo\n\n\t\tif checkInfo.Status != domain.StatusHealthy {\n\t\t\treadiness.Status = domain.StatusUnhealthy\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn readiness\n}\n\nfunc (s *healthService) AddCheck(check domain.Check) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.checks[check.Name()] = check\n}\n\nfunc (s *healthService) RemoveCheck(name string) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tdelete(s.checks, name)\n}\n\nfunc (s *healthService) getServiceInfo() domain.ServiceInfo {\n\treturn domain.ServiceInfo{\n\t\tName:        s.cfg.ServiceName,\n\t\tVersion:     s.cfg.ServiceVersion,\n\t\tEnvironment: s.cfg.Environment,\n\t\tInstance:    s.cfg.ServiceName + \"-\" + time.Now().Format(\"20060102150405\"),\n\t}\n}\n\n// CachedCheck interface for checks that support caching\ntype CachedCheck interface {\n\tdomain.Check\n\tCachedCheck() domain.CheckInfo\n}\n\n// CachedDatabaseCheck implements domain.Check with caching for database connectivity\ntype CachedDatabaseCheck struct {\n\tdb         *database.Database\n\tlastCheck  time.Time\n\tlastResult domain.CheckInfo\n\tcacheTTL   time.Duration\n\tmu         sync.RWMutex\n}\n\nfunc NewCachedDatabaseCheck(db *database.Database, cacheTTL time.Duration) *CachedDatabaseCheck {\n\treturn \u0026CachedDatabaseCheck{\n\t\tdb:       db,\n\t\tcacheTTL: cacheTTL,\n\t}\n}\n\nfunc (c *CachedDatabaseCheck) Name() string {\n\treturn \"database\"\n}\n\n// Check performs a fresh database connectivity check\nfunc (c *CachedDatabaseCheck) Check() domain.CheckInfo {\n\treturn c.performCheck()\n}\n\n// CachedCheck returns cached result if still valid, otherwise performs fresh check\nfunc (c *CachedDatabaseCheck) CachedCheck() domain.CheckInfo {\n\tc.mu.RLock()\n\tif time.Since(c.lastCheck) \u003c c.cacheTTL \u0026\u0026 !c.lastCheck.IsZero() {\n\t\tresult := c.lastResult\n\t\tc.mu.RUnlock()\n\t\treturn result\n\t}\n\tc.mu.RUnlock()\n\n\t// Cache is expired or empty, perform fresh check\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\t// Double-check in case another goroutine updated the cache\n\tif time.Since(c.lastCheck) \u003c c.cacheTTL \u0026\u0026 !c.lastCheck.IsZero() {\n\t\treturn c.lastResult\n\t}\n\n\t// Perform fresh check and cache result\n\tc.lastResult = c.performCheck()\n\tc.lastCheck = time.Now()\n\treturn c.lastResult\n}\n\nfunc (c *CachedDatabaseCheck) performCheck() domain.CheckInfo {\n\tstart := time.Now()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tvar result int\n\terr := c.db.WithContext(ctx).Raw(\"SELECT 1\").Scan(\u0026result).Error\n\tduration := time.Since(start)\n\n\tif err != nil {\n\t\treturn domain.CheckInfo{\n\t\t\tStatus:    domain.StatusUnhealthy,\n\t\t\tMessage:   \"database connection failed: \" + err.Error(),\n\t\t\tDuration:  duration,\n\t\t\tTimestamp: time.Now(),\n\t\t}\n\t}\n\n\treturn domain.CheckInfo{\n\t\tStatus:    domain.StatusHealthy,\n\t\tMessage:   \"database connection successful\",\n\t\tDuration:  duration,\n\t\tTimestamp: time.Now(),\n\t}\n}\n",
      "size": 4968,
      "hash": "2e33830513bd98a8d7f74b5567f117677d5b81730b08d3f07f05902123c8ccae",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/health/transport/http.go",
      "template": true,
      "content": "package transport\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/acheevo/api-template/internal/health/domain\"\n\t\"github.com/acheevo/api-template/internal/health/service\"\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype HealthHandler struct {\n\tservice service.HealthService\n}\n\nfunc NewHealthHandler(service service.HealthService) *HealthHandler {\n\treturn \u0026HealthHandler{\n\t\tservice: service,\n\t}\n}\n\nfunc (h *HealthHandler) RegisterRoutes(r *gin.Engine) {\n\tr.GET(\"/health\", h.Health)\n\tr.GET(\"/ready\", h.Readiness)\n\tr.GET(\"/live\", h.Liveness)\n}\n\n// Health returns detailed health information including all checks\nfunc (h *HealthHandler) Health(c *gin.Context) {\n\thealth := h.service.GetHealth()\n\n\tstatusCode := http.StatusOK\n\tswitch health.Status {\n\tcase domain.StatusUnhealthy:\n\t\tstatusCode = http.StatusServiceUnavailable\n\tcase domain.StatusDegraded:\n\t\tstatusCode = http.StatusOK // Still operational but degraded\n\t}\n\n\tc.JSON(statusCode, health)\n}\n\n// Readiness indicates if the service is ready to accept traffic\nfunc (h *HealthHandler) Readiness(c *gin.Context) {\n\treadiness := h.service.GetReadiness()\n\n\tstatusCode := http.StatusOK\n\tif readiness.Status != domain.StatusHealthy {\n\t\tstatusCode = http.StatusServiceUnavailable\n\t}\n\n\tc.JSON(statusCode, readiness)\n}\n\n// Liveness is a simple check to see if the service is alive\nfunc (h *HealthHandler) Liveness(c *gin.Context) {\n\tc.JSON(http.StatusOK, gin.H{\n\t\t\"status\":    \"alive\",\n\t\t\"timestamp\": h.service.GetHealth().Timestamp,\n\t})\n}\n",
      "size": 1457,
      "hash": "7f6501de95abc769697daca12d58812e029d92879479d47370211562f4538ad4",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/http/server.go",
      "template": true,
      "content": "package http\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"net/http\"\n\n\tauthservice \"github.com/acheevo/api-template/internal/auth/service\"\n\t\"github.com/acheevo/api-template/internal/health/transport\"\n\tinfotransport \"github.com/acheevo/api-template/internal/info/transport\"\n\t\"github.com/acheevo/api-template/internal/middleware\"\n\t\"github.com/acheevo/api-template/internal/shared/config\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\ntype Server struct {\n\tserver *http.Server\n\tlogger *slog.Logger\n}\n\nfunc NewServer(cfg *config.Config, logger *slog.Logger, healthHandler *transport.HealthHandler,\n\tinfoHandler *infotransport.InfoHandler, jwtService authservice.JWTService,\n) *Server {\n\tif cfg.IsProduction() {\n\t\tgin.SetMode(gin.ReleaseMode)\n\t}\n\n\trouter := gin.New()\n\n\trouter.Use(middleware.RequestID())\n\trouter.Use(middleware.Recovery(logger))\n\trouter.Use(middleware.Logging(logger))\n\n\tif cfg.MetricsEnabled {\n\t\trouter.Use(middleware.Metrics())\n\t\t// Prometheus metrics endpoint\n\t\trouter.GET(\"/metrics\", gin.WrapH(promhttp.Handler()))\n\t}\n\n\t// Register health endpoints\n\thealthHandler.RegisterRoutes(router)\n\n\tjwtMiddleware := middleware.JWTAuth(jwtService, logger)\n\n\t// API routes for microservice endpoints\n\tapi := router.Group(\"/api/v1\")\n\tapi.Use(jwtMiddleware) // Protect all API routes\n\t{\n\t\tinfoHandler.RegisterRoutes(api)\n\t}\n\n\tserver := \u0026http.Server{\n\t\tAddr:         cfg.HTTPAddr,\n\t\tHandler:      router,\n\t\tReadTimeout:  cfg.ReadTimeoutDuration(),\n\t\tWriteTimeout: cfg.WriteTimeoutDuration(),\n\t\tIdleTimeout:  cfg.IdleTimeoutDuration(),\n\t}\n\n\treturn \u0026Server{\n\t\tserver: server,\n\t\tlogger: logger,\n\t}\n}\n\nfunc (s *Server) Start() error {\n\ts.logger.Info(\"starting HTTP server\", \"addr\", s.server.Addr)\n\n\tif err := s.server.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\treturn fmt.Errorf(\"failed to start server: %w\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (s *Server) Stop(ctx context.Context) error {\n\ts.logger.Info(\"stopping HTTP server\")\n\treturn s.server.Shutdown(ctx)\n}\n",
      "size": 2014,
      "hash": "f4544a82a6ee8bf88c87a94598f0e1a7aca3055fcc9ef765b1cc7e360f181c95",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/info/domain/types.go",
      "template": true,
      "content": "package domain\n\nimport \"time\"\n\ntype InfoResponse struct {\n\tService      ServiceInfo      `json:\"service\"`\n\tSystem       SystemInfo       `json:\"system\"`\n\tDependencies DependencyStatus `json:\"dependencies\"`\n\tTimestamp    time.Time        `json:\"timestamp\"`\n}\n\ntype ServiceInfo struct {\n\tName        string `json:\"name\"`\n\tVersion     string `json:\"version\"`\n\tEnvironment string `json:\"environment\"`\n\tInstance    string `json:\"instance\"`\n\tUptime      string `json:\"uptime\"`\n}\n\ntype SystemInfo struct {\n\tGoVersion    string `json:\"go_version\"`\n\tPlatform     string `json:\"platform\"`\n\tNumCPU       int    `json:\"num_cpu\"`\n\tNumGoroutine int    `json:\"num_goroutine\"`\n}\n\ntype DependencyStatus struct {\n\tDatabase DatabaseStatus `json:\"database\"`\n}\n\ntype DatabaseStatus struct {\n\tStatus       string        `json:\"status\"`\n\tReachable    bool          `json:\"reachable\"`\n\tResponseTime time.Duration `json:\"response_time\"`\n\tError        string        `json:\"error,omitempty\"`\n}\n",
      "size": 967,
      "hash": "dc1c9d26f4284c5a6f34e6140a33be48a5db04f5b297d55f5936594db7cc65db",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/info/service/info.go",
      "template": true,
      "content": "package service\n\nimport (\n\t\"context\"\n\t\"log/slog\"\n\t\"runtime\"\n\t\"time\"\n\n\t\"github.com/acheevo/api-template/internal/info/domain\"\n\t\"github.com/acheevo/api-template/internal/shared/config\"\n\t\"github.com/acheevo/api-template/internal/shared/database\"\n)\n\ntype InfoService interface {\n\tGetInfo() *domain.InfoResponse\n}\n\ntype infoService struct {\n\tcfg       *config.Config\n\tdb        *database.Database\n\tlogger    *slog.Logger\n\tstartTime time.Time\n}\n\nfunc NewInfoService(cfg *config.Config, db *database.Database, logger *slog.Logger) InfoService {\n\treturn \u0026infoService{\n\t\tcfg:       cfg,\n\t\tdb:        db,\n\t\tlogger:    logger,\n\t\tstartTime: time.Now(),\n\t}\n}\n\nfunc (s *infoService) GetInfo() *domain.InfoResponse {\n\tnow := time.Now()\n\n\treturn \u0026domain.InfoResponse{\n\t\tService:      s.getServiceInfo(now),\n\t\tSystem:       s.getSystemInfo(),\n\t\tDependencies: s.getDependencyStatus(),\n\t\tTimestamp:    now,\n\t}\n}\n\nfunc (s *infoService) getServiceInfo(now time.Time) domain.ServiceInfo {\n\tuptime := now.Sub(s.startTime)\n\n\treturn domain.ServiceInfo{\n\t\tName:        s.cfg.ServiceName,\n\t\tVersion:     s.cfg.ServiceVersion,\n\t\tEnvironment: s.cfg.Environment,\n\t\tInstance:    s.cfg.GetServiceID(),\n\t\tUptime:      uptime.String(),\n\t}\n}\n\nfunc (s *infoService) getSystemInfo() domain.SystemInfo {\n\treturn domain.SystemInfo{\n\t\tGoVersion:    runtime.Version(),\n\t\tPlatform:     runtime.GOOS + \"/\" + runtime.GOARCH,\n\t\tNumCPU:       runtime.NumCPU(),\n\t\tNumGoroutine: runtime.NumGoroutine(),\n\t}\n}\n\nfunc (s *infoService) getDependencyStatus() domain.DependencyStatus {\n\treturn domain.DependencyStatus{\n\t\tDatabase: s.checkDatabaseStatus(),\n\t}\n}\n\nfunc (s *infoService) checkDatabaseStatus() domain.DatabaseStatus {\n\tif s.db == nil {\n\t\treturn domain.DatabaseStatus{\n\t\t\tStatus:    \"disabled\",\n\t\t\tReachable: false,\n\t\t\tError:     \"database not configured\",\n\t\t}\n\t}\n\n\tstart := time.Now()\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tvar result int\n\terr := s.db.WithContext(ctx).Raw(\"SELECT 1\").Scan(\u0026result).Error\n\tresponseTime := time.Since(start)\n\n\tif err != nil {\n\t\ts.logger.Warn(\"database health check failed\", \"error\", err, \"response_time\", responseTime)\n\t\treturn domain.DatabaseStatus{\n\t\t\tStatus:       \"unhealthy\",\n\t\t\tReachable:    false,\n\t\t\tResponseTime: responseTime,\n\t\t\tError:        err.Error(),\n\t\t}\n\t}\n\n\treturn domain.DatabaseStatus{\n\t\tStatus:       \"healthy\",\n\t\tReachable:    true,\n\t\tResponseTime: responseTime,\n\t}\n}\n",
      "size": 2430,
      "hash": "05e9342033ee66fdf87bc6f656a5cb75f674a979dba70e4398e45171a4508b59",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/info/transport/http.go",
      "template": true,
      "content": "package transport\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/acheevo/api-template/internal/info/service\"\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype InfoHandler struct {\n\tservice service.InfoService\n}\n\nfunc NewInfoHandler(service service.InfoService) *InfoHandler {\n\treturn \u0026InfoHandler{\n\t\tservice: service,\n\t}\n}\n\nfunc (h *InfoHandler) RegisterRoutes(r *gin.RouterGroup) {\n\tr.GET(\"/info\", h.GetInfo)\n}\n\nfunc (h *InfoHandler) GetInfo(c *gin.Context) {\n\tinfo := h.service.GetInfo()\n\n\t// Set appropriate status code based on dependency health\n\tstatusCode := http.StatusOK\n\tif !info.Dependencies.Database.Reachable \u0026\u0026 info.Dependencies.Database.Status != \"disabled\" {\n\t\tstatusCode = http.StatusServiceUnavailable\n\t}\n\n\tc.JSON(statusCode, info)\n}\n",
      "size": 726,
      "hash": "3bf44600796b134c7e01d294b84bead8b8d7b527cddacbae6fc8400e2408424a",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/middleware/jwt.go",
      "template": true,
      "content": "package middleware\n\nimport (\n\t\"log/slog\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/acheevo/api-template/internal/auth/service\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nconst (\n\tAuthorizationHeader = \"Authorization\"\n\tBearerPrefix        = \"Bearer \"\n\tServiceContextKey   = \"service\"\n)\n\nfunc JWTAuth(jwtService service.JWTService, logger *slog.Logger) gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tauthHeader := c.GetHeader(AuthorizationHeader)\n\t\tif authHeader == \"\" {\n\t\t\tlogger.Warn(\"missing authorization header\", \"ip\", c.ClientIP(), \"path\", c.Request.URL.Path)\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"authorization header required\"})\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\n\t\tif !strings.HasPrefix(authHeader, BearerPrefix) {\n\t\t\tlogger.Warn(\"invalid authorization format\", \"ip\", c.ClientIP())\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"bearer token required\"})\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\n\t\ttokenString := strings.TrimPrefix(authHeader, BearerPrefix)\n\t\tclaims, err := jwtService.ValidateToken(tokenString)\n\t\tif err != nil {\n\t\t\tlogger.Warn(\"invalid token attempt\", \"error\", err, \"ip\", c.ClientIP())\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"invalid token\"})\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\n\t\tc.Set(ServiceContextKey, claims)\n\t\tc.Next()\n\t}\n}\n\nfunc RequireService(serviceName string) gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tserviceCtx, exists := c.Get(ServiceContextKey)\n\t\tif !exists {\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\"error\": \"authentication required\"})\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\n\t\tclaims, ok := serviceCtx.(*service.Claims)\n\t\tif !ok {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"invalid service context\"})\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\n\t\tif claims.ServiceName != serviceName {\n\t\t\tc.JSON(http.StatusForbidden, gin.H{\"error\": \"service not authorized\"})\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\n\t\tc.Next()\n\t}\n}\n",
      "size": 1830,
      "hash": "863148cf1975231294fcda4f80441e359c71f136e41236814d6641c784c8b262",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/middleware/logging.go",
      "template": true,
      "content": "package middleware\n\nimport (\n\t\"log/slog\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc Logging(logger *slog.Logger) gin.HandlerFunc {\n\treturn gin.HandlerFunc(func(c *gin.Context) {\n\t\tstart := time.Now()\n\t\tpath := c.Request.URL.Path\n\t\tmethod := c.Request.Method\n\n\t\tc.Next()\n\n\t\tend := time.Now()\n\t\tlatency := end.Sub(start)\n\t\tstatus := c.Writer.Status()\n\t\tclientIP := c.ClientIP()\n\t\tuserAgent := c.Request.UserAgent()\n\n\t\trequestID, _ := c.Get(\"request_id\")\n\n\t\tlogger.Info(\"HTTP request\",\n\t\t\t\"method\", method,\n\t\t\t\"path\", path,\n\t\t\t\"status\", status,\n\t\t\t\"latency\", latency,\n\t\t\t\"client_ip\", clientIP,\n\t\t\t\"user_agent\", userAgent,\n\t\t\t\"request_id\", requestID,\n\t\t)\n\t})\n}\n",
      "size": 659,
      "hash": "cb09a96001afe7e1923c7dd31473ad0bafea4c4136e0ae29257181e9b4d3ab61",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/middleware/metrics.go",
      "template": true,
      "content": "package middleware\n\nimport (\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promauto\"\n)\n\nvar (\n\thttpRequestsTotal = promauto.NewCounterVec(\n\t\tprometheus.CounterOpts{\n\t\t\tName: \"http_requests_total\",\n\t\t\tHelp: \"The total number of HTTP requests\",\n\t\t},\n\t\t[]string{\"method\", \"path\", \"status\"},\n\t)\n\n\thttpRequestDuration = promauto.NewHistogramVec(\n\t\tprometheus.HistogramOpts{\n\t\t\tName:    \"http_request_duration_seconds\",\n\t\t\tHelp:    \"The HTTP request latencies in seconds\",\n\t\t\tBuckets: prometheus.DefBuckets,\n\t\t},\n\t\t[]string{\"method\", \"path\", \"status\"},\n\t)\n\n\thttpRequestsInFlight = promauto.NewGauge(\n\t\tprometheus.GaugeOpts{\n\t\t\tName: \"http_requests_in_flight\",\n\t\t\tHelp: \"The current number of HTTP requests being served\",\n\t\t},\n\t)\n\n\thttpRequestSize = promauto.NewHistogramVec(\n\t\tprometheus.HistogramOpts{\n\t\t\tName:    \"http_request_size_bytes\",\n\t\t\tHelp:    \"The HTTP request sizes in bytes\",\n\t\t\tBuckets: prometheus.ExponentialBuckets(100, 10, 7),\n\t\t},\n\t\t[]string{\"method\", \"path\"},\n\t)\n\n\thttpResponseSize = promauto.NewHistogramVec(\n\t\tprometheus.HistogramOpts{\n\t\t\tName:    \"http_response_size_bytes\",\n\t\t\tHelp:    \"The HTTP response sizes in bytes\",\n\t\t\tBuckets: prometheus.ExponentialBuckets(100, 10, 7),\n\t\t},\n\t\t[]string{\"method\", \"path\", \"status\"},\n\t)\n)\n\nfunc Metrics() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tstart := time.Now()\n\n\t\t// Increment in-flight requests\n\t\thttpRequestsInFlight.Inc()\n\t\tdefer httpRequestsInFlight.Dec()\n\n\t\t// Record request size\n\t\trequestSize := computeApproximateRequestSize(c.Request)\n\t\thttpRequestSize.WithLabelValues(c.Request.Method, c.FullPath()).Observe(float64(requestSize))\n\n\t\t// Process request\n\t\tc.Next()\n\n\t\t// Record metrics after request completion\n\t\tduration := time.Since(start).Seconds()\n\t\tstatus := strconv.Itoa(c.Writer.Status())\n\t\tmethod := c.Request.Method\n\t\tpath := c.FullPath()\n\n\t\t// If path is empty (like for 404), use the requested path\n\t\tif path == \"\" {\n\t\t\tpath = c.Request.URL.Path\n\t\t}\n\n\t\thttpRequestsTotal.WithLabelValues(method, path, status).Inc()\n\t\thttpRequestDuration.WithLabelValues(method, path, status).Observe(duration)\n\t\thttpResponseSize.WithLabelValues(method, path, status).Observe(float64(c.Writer.Size()))\n\t}\n}\n\n// computeApproximateRequestSize returns the approximate size of the request in bytes\nfunc computeApproximateRequestSize(r *http.Request) int {\n\tsize := 0\n\tif r.URL != nil {\n\t\tsize += len(r.URL.Path)\n\t}\n\n\tsize += len(r.Method)\n\tsize += len(r.Proto)\n\n\tfor name, values := range r.Header {\n\t\tsize += len(name)\n\t\tfor _, value := range values {\n\t\t\tsize += len(value)\n\t\t}\n\t}\n\n\tsize += len(r.Host)\n\n\tif r.ContentLength != -1 {\n\t\tsize += int(r.ContentLength)\n\t}\n\n\treturn size\n}\n",
      "size": 2764,
      "hash": "b3660edc5cfcbe3e459136e3e66d6d02fbdcdb8553d26bb56791b1bce0dacd10",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/middleware/ratelimit.go",
      "template": true,
      "content": "package middleware\n\nimport (\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/acheevo/api-template/internal/auth/service\"\n\t\"github.com/gin-gonic/gin\"\n\t\"golang.org/x/time/rate\"\n)\n\ntype RateLimiter struct {\n\tlimiters map[string]*rate.Limiter\n\tmu       sync.RWMutex\n\trate     rate.Limit\n\tburst    int\n\tcleanup  time.Duration\n}\n\nfunc NewRateLimiter(rps float64, burst int, cleanup time.Duration) *RateLimiter {\n\trl := \u0026RateLimiter{\n\t\tlimiters: make(map[string]*rate.Limiter),\n\t\trate:     rate.Limit(rps),\n\t\tburst:    burst,\n\t\tcleanup:  cleanup,\n\t}\n\n\t// Start cleanup goroutine\n\tgo rl.cleanupRoutine()\n\n\treturn rl\n}\n\nfunc (rl *RateLimiter) getLimiter(key string) *rate.Limiter {\n\trl.mu.Lock()\n\tdefer rl.mu.Unlock()\n\n\tlimiter, exists := rl.limiters[key]\n\tif !exists {\n\t\tlimiter = rate.NewLimiter(rl.rate, rl.burst)\n\t\trl.limiters[key] = limiter\n\t}\n\n\treturn limiter\n}\n\nfunc (rl *RateLimiter) cleanupRoutine() {\n\tticker := time.NewTicker(rl.cleanup)\n\tdefer ticker.Stop()\n\n\tfor range ticker.C {\n\t\trl.mu.Lock()\n\t\tfor key, limiter := range rl.limiters {\n\t\t\t// Remove limiters that haven't been used recently\n\t\t\tif limiter.TokensAt(time.Now()) == float64(rl.burst) {\n\t\t\t\tdelete(rl.limiters, key)\n\t\t\t}\n\t\t}\n\t\trl.mu.Unlock()\n\t}\n}\n\n// RateLimit creates a rate limiting middleware\n// rps: requests per second\n// burst: maximum burst size\n// cleanup: cleanup interval for unused limiters\nfunc RateLimit(rps float64, burst int, cleanup time.Duration) gin.HandlerFunc {\n\tlimiter := NewRateLimiter(rps, burst, cleanup)\n\n\treturn func(c *gin.Context) {\n\t\tkey := c.ClientIP()\n\n\t\tif !limiter.getLimiter(key).Allow() {\n\t\t\tc.JSON(http.StatusTooManyRequests, gin.H{\n\t\t\t\t\"error\":   \"rate limit exceeded\",\n\t\t\t\t\"message\": \"too many requests from this IP\",\n\t\t\t})\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\n\t\tc.Next()\n\t}\n}\n\n// RateLimitByService creates a rate limiting middleware for service-to-service calls\nfunc RateLimitByService(rps float64, burst int, cleanup time.Duration) gin.HandlerFunc {\n\tlimiter := NewRateLimiter(rps, burst, cleanup)\n\n\treturn func(c *gin.Context) {\n\t\t// Try to get service name from JWT claims\n\t\tvar key string\n\t\tif serviceCtx, exists := c.Get(ServiceContextKey); exists {\n\t\t\tif claims, ok := serviceCtx.(*service.Claims); ok {\n\t\t\t\tkey = claims.ServiceName\n\t\t\t}\n\t\t}\n\n\t\t// Fallback to IP if no service context\n\t\tif key == \"\" {\n\t\t\tkey = c.ClientIP()\n\t\t}\n\n\t\tif !limiter.getLimiter(key).Allow() {\n\t\t\tc.JSON(http.StatusTooManyRequests, gin.H{\n\t\t\t\t\"error\":   \"rate limit exceeded\",\n\t\t\t\t\"message\": \"too many requests from service: \" + key,\n\t\t\t})\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\n\t\tc.Next()\n\t}\n}\n",
      "size": 2557,
      "hash": "7517991ccdc93f5bbc54d7945ad787bb7e10fc3dc52f69d28b58a4337e420065",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/middleware/recovery.go",
      "template": true,
      "content": "package middleware\n\nimport (\n\t\"log/slog\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc Recovery(logger *slog.Logger) gin.HandlerFunc {\n\treturn gin.RecoveryWithWriter(gin.DefaultWriter, func(c *gin.Context, recovered interface{}) {\n\t\tlogger.Error(\"panic recovered\",\n\t\t\t\"error\", recovered,\n\t\t\t\"method\", c.Request.Method,\n\t\t\t\"path\", c.Request.URL.Path,\n\t\t\t\"client_ip\", c.ClientIP(),\n\t\t)\n\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\n\t\t\t\"error\": \"internal server error\",\n\t\t})\n\t})\n}\n",
      "size": 484,
      "hash": "d492b5deb20e50d95b55d466c5c20f3f11f91072eae56e3772205c698247d876",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/middleware/request_id.go",
      "template": true,
      "content": "package middleware\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/google/uuid\"\n)\n\nconst RequestIDHeader = \"X-Request-ID\"\n\nfunc RequestID() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\trequestID := c.GetHeader(RequestIDHeader)\n\t\tif requestID == \"\" {\n\t\t\trequestID = uuid.New().String()\n\t\t}\n\n\t\tc.Set(\"request_id\", requestID)\n\t\tc.Header(RequestIDHeader, requestID)\n\t\tc.Next()\n\t}\n}\n",
      "size": 387,
      "hash": "ee3b2b9185520239b7f0d34517b393982a6f147e67ce6ea9fe372a3e5316f901",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/shared/config/config.go",
      "template": true,
      "content": "package config\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/kelseyhightower/envconfig\"\n)\n\ntype Config struct {\n\t// HTTP Server Configuration\n\tHTTPAddr     string `envconfig:\"HTTP_ADDR\" default:\":8080\"`       // Server listen address and port\n\tReadTimeout  string `envconfig:\"READ_TIMEOUT\" default:\"15s\"`       // Maximum duration for reading the entire request\n\tWriteTimeout string `envconfig:\"WRITE_TIMEOUT\" default:\"15s\"`      // Maximum duration before timing out writes of the response\n\tIdleTimeout  string `envconfig:\"IDLE_TIMEOUT\" default:\"60s\"`       // Maximum time to wait for the next request when keep-alives are enabled\n\n\t// Database Configuration (optional for some microservices)\n\tDBHost            string `envconfig:\"DB_HOST\" default:\"localhost\"`    // Database host address\n\tDBPort            string `envconfig:\"DB_PORT\" default:\"5432\"`         // Database port number\n\tDBUser            string `envconfig:\"DB_USER\" default:\"postgres\"`     // Database username for authentication\n\tDBPassword        string `envconfig:\"DB_PASSWORD\" default:\"postgres\"` // Database password for authentication\n\tDBName            string `envconfig:\"DB_NAME\" default:\"api_template\"` // Database name to connect to\n\tDBSSLMode         string `envconfig:\"DB_SSL_MODE\" default:\"disable\"`  // SSL mode for database connection (disable, require, verify-ca, verify-full)\n\tDBMaxIdleConns    int    `envconfig:\"DB_MAX_IDLE_CONNS\" default:\"10\"`  // Maximum number of idle connections in the pool\n\tDBMaxOpenConns    int    `envconfig:\"DB_MAX_OPEN_CONNS\" default:\"100\"` // Maximum number of open connections to the database\n\tDBConnMaxLifetime string `envconfig:\"DB_CONN_MAX_LIFETIME\" default:\"1h\"` // Maximum amount of time a connection may be reused\n\n\t// Service Identity\n\tServiceName    string `envconfig:\"SERVICE_NAME\" default:\"api-template\"` // Name of this service for identification and logging\n\tServiceVersion string `envconfig:\"SERVICE_VERSION\" default:\"1.0.0\"`     // Version of this service for tracking and compatibility\n\tServiceID      string `envconfig:\"SERVICE_ID\" default:\"\"`              // Unique identifier for this service instance (auto-generated if empty)\n\n\t// Logging Configuration\n\tLogLevel    string `envconfig:\"LOG_LEVEL\" default:\"info\"`        // Log level (debug, info, warn, error)\n\tEnvironment string `envconfig:\"ENVIRONMENT\" default:\"development\"` // Application environment (development, staging, production)\n\n\t// Security Configuration\n\tJWTSecret     string `envconfig:\"JWT_SECRET\" default:\"development-jwt-secret\"` // Secret key for signing JWT tokens\n\tJWTExpiration string `envconfig:\"JWT_EXPIRATION\" default:\"24h\"`                // JWT token expiration duration\n\n\t// Observability\n\tMetricsEnabled bool `envconfig:\"METRICS_ENABLED\" default:\"true\"` // Enable Prometheus metrics collection and /metrics endpoint\n}\n\nfunc Load() (*Config, error) {\n\tvar cfg Config\n\tif err := envconfig.Process(\"\", \u0026cfg); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load config: %w\", err)\n\t}\n\treturn \u0026cfg, nil\n}\n\nfunc (c *Config) DatabaseDSN() string {\n\thost := c.DBHost\n\tif host == \"localhost\" {\n\t\thost = \"127.0.0.1\"\n\t}\n\n\treturn fmt.Sprintf(\"host=%s port=%s user=%s password=%s dbname=%s sslmode=%s\",\n\t\thost, c.DBPort, c.DBUser, c.DBPassword, c.DBName, c.DBSSLMode)\n}\n\nfunc (c *Config) IsDevelopment() bool {\n\treturn c.Environment == \"development\"\n}\n\nfunc (c *Config) IsProduction() bool {\n\treturn c.Environment == \"production\"\n}\n\nfunc (c *Config) JWTExpirationDuration() time.Duration {\n\tduration, err := time.ParseDuration(c.JWTExpiration)\n\tif err != nil {\n\t\treturn 24 * time.Hour // fallback to 24 hours\n\t}\n\treturn duration\n}\n\nfunc (c *Config) ReadTimeoutDuration() time.Duration {\n\tduration, err := time.ParseDuration(c.ReadTimeout)\n\tif err != nil {\n\t\treturn 15 * time.Second\n\t}\n\treturn duration\n}\n\nfunc (c *Config) WriteTimeoutDuration() time.Duration {\n\tduration, err := time.ParseDuration(c.WriteTimeout)\n\tif err != nil {\n\t\treturn 15 * time.Second\n\t}\n\treturn duration\n}\n\nfunc (c *Config) IdleTimeoutDuration() time.Duration {\n\tduration, err := time.ParseDuration(c.IdleTimeout)\n\tif err != nil {\n\t\treturn 60 * time.Second\n\t}\n\treturn duration\n}\n\nfunc (c *Config) DBConnMaxLifetimeDuration() time.Duration {\n\tduration, err := time.ParseDuration(c.DBConnMaxLifetime)\n\tif err != nil {\n\t\treturn time.Hour\n\t}\n\treturn duration\n}\n\n\nfunc (c *Config) GetServiceID() string {\n\tif c.ServiceID == \"\" {\n\t\t// Generate a unique service ID if not provided\n\t\treturn fmt.Sprintf(\"%s-%d\", c.ServiceName, time.Now().Unix())\n\t}\n\treturn c.ServiceID\n}\n",
      "size": 4530,
      "hash": "8e7cf0f2c4905ee69f86832599f5b852ed17834f5bc2e26f41de0017576f04a6",
      "mappings": [
        {
          "find": "ServiceName    string `envconfig:\"SERVICE_NAME\" default:\"api-template\"`",
          "replace": "ServiceName    string `envconfig:\"SERVICE_NAME\" default:\"{{.ProjectName | kebab}}\"`"
        },
        {
          "find": "DBName            string `envconfig:\"DB_NAME\" default:\"api_template\"`",
          "replace": "DBName            string `envconfig:\"DB_NAME\" default:\"{{.ProjectName | lower}}\"`"
        }
      ]
    },
    {
      "path": "internal/shared/database/database.go",
      "template": true,
      "content": "package database\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"gorm.io/driver/postgres\"\n\t\"gorm.io/gorm\"\n\t\"gorm.io/gorm/logger\"\n)\n\ntype Database struct {\n\t*gorm.DB\n}\n\ntype BaseEntity struct {\n\tID        uuid.UUID `json:\"id\" gorm:\"type:uuid;primaryKey\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\"`\n}\n\nfunc (b *BaseEntity) BeforeCreate(tx *gorm.DB) error {\n\tif b.ID == uuid.Nil {\n\t\tb.ID = uuid.New()\n\t}\n\treturn nil\n}\n\nfunc New(dsn string, isDevelopment bool) (*Database, error) {\n\tlogLevel := logger.Silent\n\tif isDevelopment {\n\t\tlogLevel = logger.Info\n\t}\n\n\tconfig := \u0026gorm.Config{\n\t\tLogger: logger.Default.LogMode(logLevel),\n\t}\n\n\tdb, err := gorm.Open(postgres.Open(dsn), config)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to connect to database: %w\", err)\n\t}\n\n\t// Database connection configuration will be set by the caller\n\t// using the config values\n\n\tif err := db.Exec(\"CREATE EXTENSION IF NOT EXISTS \\\"uuid-ossp\\\"\").Error; err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create uuid extension: %w\", err)\n\t}\n\n\treturn \u0026Database{DB: db}, nil\n}\n\nfunc (d *Database) Close() error {\n\tsqlDB, err := d.DB.DB()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn sqlDB.Close()\n}\n\nfunc (d *Database) AutoMigrate(models ...interface{}) error {\n\treturn d.DB.AutoMigrate(models...)\n}\n\nfunc (d *Database) SetConnectionPool(maxIdleConns, maxOpenConns int, connMaxLifetime time.Duration) error {\n\tsqlDB, err := d.DB.DB()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsqlDB.SetMaxIdleConns(maxIdleConns)\n\tsqlDB.SetMaxOpenConns(maxOpenConns)\n\tsqlDB.SetConnMaxLifetime(connMaxLifetime)\n\n\treturn nil\n}\n",
      "size": 1615,
      "hash": "1991b1da1f54feff2b69278ca8c7e41596806362d454857c69355c863f10fe11",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "internal/shared/logger/logger.go",
      "template": true,
      "content": "package logger\n\nimport (\n\t\"log/slog\"\n\t\"os\"\n)\n\nfunc New(level string, isDevelopment bool) *slog.Logger {\n\tvar logLevel slog.Level\n\n\tswitch level {\n\tcase \"debug\":\n\t\tlogLevel = slog.LevelDebug\n\tcase \"info\":\n\t\tlogLevel = slog.LevelInfo\n\tcase \"warn\":\n\t\tlogLevel = slog.LevelWarn\n\tcase \"error\":\n\t\tlogLevel = slog.LevelError\n\tdefault:\n\t\tlogLevel = slog.LevelInfo\n\t}\n\n\topts := \u0026slog.HandlerOptions{\n\t\tLevel: logLevel,\n\t}\n\n\tvar handler slog.Handler\n\tif isDevelopment {\n\t\thandler = slog.NewTextHandler(os.Stdout, opts)\n\t} else {\n\t\thandler = slog.NewJSONHandler(os.Stdout, opts)\n\t}\n\n\treturn slog.New(handler)\n}\n",
      "size": 600,
      "hash": "c7ff9dff0ef555a0a56ccb8631bfd579f11c0c6b73306ce63771bc9fda78280c",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "tests/integration/caching_test.go",
      "template": true,
      "content": "package integration\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/acheevo/api-template/internal/health/service\"\n\t\"github.com/acheevo/api-template/internal/shared/config\"\n\t\"github.com/acheevo/api-template/internal/shared/logger\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype CachingTestSuite struct {\n\tsuite.Suite\n\tpg            *PostgresContainer\n\thealthService service.HealthService\n}\n\nfunc TestCachingTestSuite(t *testing.T) {\n\tsuite.Run(t, new(CachingTestSuite))\n}\n\nfunc (s *CachingTestSuite) SetupSuite() {\n\t// Setup PostgreSQL testcontainer\n\ts.pg = SetupPostgresContainer(s.T())\n\n\tcfg := \u0026config.Config{\n\t\tServiceName:    \"caching-test\",\n\t\tServiceVersion: \"1.0.0-test\",\n\t\tEnvironment:    \"test\",\n\t}\n\n\tappLogger := logger.New(\"error\", true)\n\ts.healthService = service.NewHealthService(cfg, s.pg.GetDB(), appLogger)\n}\n\nfunc (s *CachingTestSuite) TearDownSuite() {\n\tif s.pg != nil {\n\t\ts.pg.Cleanup(context.Background())\n\t}\n}\n\nfunc (s *CachingTestSuite) TestHealthCheckCaching() {\n\t// First health check - should hit database\n\thealth1 := s.healthService.GetHealth()\n\tassert.Equal(s.T(), \"healthy\", string(health1.Status))\n\n\tdbCheck1, exists := health1.Checks[\"database\"]\n\tassert.True(s.T(), exists)\n\tassert.Equal(s.T(), \"healthy\", string(dbCheck1.Status))\n\tfirstTimestamp := dbCheck1.Timestamp\n\n\t// Second health check immediately - should use cache\n\thealth2 := s.healthService.GetHealth()\n\tdbCheck2 := health2.Checks[\"database\"]\n\tassert.Equal(s.T(), firstTimestamp, dbCheck2.Timestamp, \"Timestamp should be the same due to caching\")\n\n\t// Wait for cache to expire (30 seconds is too long for test, but we can verify logic)\n\t// For production, you'd wait: time.Sleep(31 * time.Second)\n\t// But for test, we just verify the caching mechanism works for immediate calls\n}\n\nfunc (s *CachingTestSuite) TestReadinessAlwaysFresh() {\n\t// First readiness check\n\treadiness1 := s.healthService.GetReadiness()\n\tassert.Equal(s.T(), \"healthy\", string(readiness1.Status))\n\n\tdbCheck1, exists := readiness1.Checks[\"database\"]\n\tassert.True(s.T(), exists)\n\tfirstTimestamp := dbCheck1.Timestamp\n\n\t// Small delay to ensure timestamp difference\n\ttime.Sleep(10 * time.Millisecond)\n\n\t// Second readiness check - should always be fresh\n\treadiness2 := s.healthService.GetReadiness()\n\tdbCheck2 := readiness2.Checks[\"database\"]\n\tassert.True(s.T(), dbCheck2.Timestamp.After(firstTimestamp), \"Readiness should always perform fresh checks\")\n}\n\nfunc (s *CachingTestSuite) TestMixedHealthAndReadiness() {\n\t// Health check first (cached)\n\thealth := s.healthService.GetHealth()\n\thealthDbCheck := health.Checks[\"database\"]\n\thealthTimestamp := healthDbCheck.Timestamp\n\n\t// Readiness check (fresh)\n\treadiness := s.healthService.GetReadiness()\n\treadinessDbCheck := readiness.Checks[\"database\"]\n\n\t// Readiness timestamp should be newer than health (fresh check)\n\tassert.True(s.T(), readinessDbCheck.Timestamp.After(healthTimestamp) ||\n\t\treadinessDbCheck.Timestamp.Equal(healthTimestamp))\n\n\t// Another health check immediately (should use cache)\n\thealth2 := s.healthService.GetHealth()\n\thealthDbCheck2 := health2.Checks[\"database\"]\n\tassert.Equal(s.T(), healthTimestamp, healthDbCheck2.Timestamp, \"Health check should still use cached result\")\n}\n",
      "size": 3248,
      "hash": "9b6f451030eea760b43200fcca3b47818e5fb3d487396f8b141b8868d5915fd1",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "tests/integration/health_test.go",
      "template": true,
      "content": "package integration\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/acheevo/api-template/internal/health/domain\"\n\t\"github.com/acheevo/api-template/internal/health/service\"\n\t\"github.com/acheevo/api-template/internal/health/transport\"\n\t\"github.com/acheevo/api-template/internal/shared/config\"\n\t\"github.com/acheevo/api-template/internal/shared/logger\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype HealthIntegrationTestSuite struct {\n\tsuite.Suite\n\trouter *gin.Engine\n\tpg     *PostgresContainer\n}\n\nfunc TestHealthIntegrationSuite(t *testing.T) {\n\tsuite.Run(t, new(HealthIntegrationTestSuite))\n}\n\nfunc (s *HealthIntegrationTestSuite) SetupSuite() {\n\tgin.SetMode(gin.TestMode)\n\n\t// Setup PostgreSQL testcontainer\n\ts.pg = SetupPostgresContainer(s.T())\n\n\tcfg := \u0026config.Config{\n\t\tServiceName:    \"api-template-test\",\n\t\tServiceVersion: \"1.0.0-test\",\n\t\tEnvironment:    \"test\",\n\t}\n\n\tappLogger := logger.New(\"error\", true)\n\n\t// Create health service with real database\n\thealthService := service.NewHealthService(cfg, s.pg.GetDB(), appLogger)\n\thealthHandler := transport.NewHealthHandler(healthService)\n\n\ts.router = gin.New()\n\thealthHandler.RegisterRoutes(s.router)\n}\n\nfunc (s *HealthIntegrationTestSuite) TestHealthEndpoint() {\n\treq := httptest.NewRequest(http.MethodGet, \"/health\", nil)\n\tw := httptest.NewRecorder()\n\ts.router.ServeHTTP(w, req)\n\n\tassert.Equal(s.T(), http.StatusOK, w.Code)\n\n\tvar response domain.HealthResponse\n\terr := json.Unmarshal(w.Body.Bytes(), \u0026response)\n\tassert.NoError(s.T(), err)\n\n\tassert.Equal(s.T(), domain.StatusHealthy, response.Status)\n\tassert.Equal(s.T(), \"api-template-test\", response.Service.Name)\n\tassert.Equal(s.T(), \"1.0.0-test\", response.Service.Version)\n\tassert.Equal(s.T(), \"test\", response.Service.Environment)\n\tassert.True(s.T(), response.Uptime \u003e 0)\n\n\t// Check database check is healthy\n\tdbCheck, exists := response.Checks[\"database\"]\n\tassert.True(s.T(), exists, \"database check should exist\")\n\tassert.Equal(s.T(), domain.StatusHealthy, dbCheck.Status)\n\tassert.Contains(s.T(), dbCheck.Message, \"database connection successful\")\n}\n\nfunc (s *HealthIntegrationTestSuite) TestReadinessEndpoint() {\n\treq := httptest.NewRequest(http.MethodGet, \"/ready\", nil)\n\tw := httptest.NewRecorder()\n\ts.router.ServeHTTP(w, req)\n\n\tassert.Equal(s.T(), http.StatusOK, w.Code)\n\n\tvar response domain.ReadinessResponse\n\terr := json.Unmarshal(w.Body.Bytes(), \u0026response)\n\tassert.NoError(s.T(), err)\n\n\tassert.Equal(s.T(), domain.StatusHealthy, response.Status)\n\tassert.Equal(s.T(), \"api-template-test\", response.Service.Name)\n}\n\nfunc (s *HealthIntegrationTestSuite) TestLivenessEndpoint() {\n\treq := httptest.NewRequest(http.MethodGet, \"/live\", nil)\n\tw := httptest.NewRecorder()\n\ts.router.ServeHTTP(w, req)\n\n\tassert.Equal(s.T(), http.StatusOK, w.Code)\n\n\tvar response map[string]interface{}\n\terr := json.Unmarshal(w.Body.Bytes(), \u0026response)\n\tassert.NoError(s.T(), err)\n\n\tassert.Equal(s.T(), \"alive\", response[\"status\"])\n\tassert.NotNil(s.T(), response[\"timestamp\"])\n}\n\nfunc (s *HealthIntegrationTestSuite) TearDownSuite() {\n\tctx := context.Background()\n\tif s.pg != nil {\n\t\ts.pg.Cleanup(ctx)\n\t}\n}\n",
      "size": 3209,
      "hash": "f7c55206baa3b87e20da64f23cc4ec076776440b68593f8c13381ac80756c8fa",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "tests/integration/info_test.go",
      "template": true,
      "content": "package integration\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\t\"time\"\n\n\tauthservice \"github.com/acheevo/api-template/internal/auth/service\"\n\t\"github.com/acheevo/api-template/internal/info/domain\"\n\t\"github.com/acheevo/api-template/internal/info/service\"\n\t\"github.com/acheevo/api-template/internal/info/transport\"\n\t\"github.com/acheevo/api-template/internal/middleware\"\n\t\"github.com/acheevo/api-template/internal/shared/config\"\n\t\"github.com/acheevo/api-template/internal/shared/logger\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype InfoIntegrationTestSuite struct {\n\tsuite.Suite\n\trouter     *gin.Engine\n\tjwtService authservice.JWTService\n\tpg         *PostgresContainer\n}\n\nfunc TestInfoIntegrationSuite(t *testing.T) {\n\tsuite.Run(t, new(InfoIntegrationTestSuite))\n}\n\nfunc (s *InfoIntegrationTestSuite) SetupSuite() {\n\tgin.SetMode(gin.TestMode)\n\n\t// Setup PostgreSQL testcontainer\n\ts.pg = SetupPostgresContainer(s.T())\n\n\tcfg := \u0026config.Config{\n\t\tServiceName:    \"api-template-test\",\n\t\tServiceVersion: \"1.0.0-test\",\n\t\tEnvironment:    \"test\",\n\t\tJWTSecret:      \"test-secret\",\n\t}\n\n\tappLogger := logger.New(\"error\", true)\n\ts.jwtService = authservice.NewJWTService(cfg.JWTSecret, 24*time.Hour)\n\n\t// Create info service with real database\n\tinfoService := service.NewInfoService(cfg, s.pg.GetDB(), appLogger)\n\tinfoHandler := transport.NewInfoHandler(infoService)\n\n\ts.router = gin.New()\n\n\t// Set up JWT middleware\n\tjwtMiddleware := middleware.JWTAuth(s.jwtService, appLogger)\n\n\tapi := s.router.Group(\"/api/v1\")\n\tapi.Use(jwtMiddleware)\n\tinfoHandler.RegisterRoutes(api)\n}\n\nfunc (s *InfoIntegrationTestSuite) TestInfoEndpoint() {\n\t// Generate a valid JWT token\n\ttoken, err := s.jwtService.GenerateServiceToken(\"test-service\", \"test-id\", \"1.0.0\", \"test\")\n\ts.Require().NoError(err)\n\n\treq := httptest.NewRequest(http.MethodGet, \"/api/v1/info\", nil)\n\treq.Header.Set(\"Authorization\", \"Bearer \"+token)\n\n\tw := httptest.NewRecorder()\n\ts.router.ServeHTTP(w, req)\n\n\tassert.Equal(s.T(), http.StatusOK, w.Code)\n\n\tvar response domain.InfoResponse\n\terr = json.Unmarshal(w.Body.Bytes(), \u0026response)\n\tassert.NoError(s.T(), err)\n\n\t// Check service info\n\tassert.Equal(s.T(), \"api-template-test\", response.Service.Name)\n\tassert.Equal(s.T(), \"1.0.0-test\", response.Service.Version)\n\tassert.Equal(s.T(), \"test\", response.Service.Environment)\n\tassert.NotEmpty(s.T(), response.Service.Instance)\n\tassert.NotEmpty(s.T(), response.Service.Uptime)\n\n\t// Check system info\n\tassert.NotEmpty(s.T(), response.System.GoVersion)\n\tassert.NotEmpty(s.T(), response.System.Platform)\n\tassert.Greater(s.T(), response.System.NumCPU, 0)\n\tassert.Greater(s.T(), response.System.NumGoroutine, 0)\n\n\t// Check dependencies (database should be healthy)\n\tassert.Equal(s.T(), \"healthy\", response.Dependencies.Database.Status)\n\tassert.True(s.T(), response.Dependencies.Database.Reachable)\n\tassert.Empty(s.T(), response.Dependencies.Database.Error)\n\n\t// Check timestamp\n\tassert.True(s.T(), response.Timestamp.Before(time.Now().Add(time.Second)))\n}\n\nfunc (s *InfoIntegrationTestSuite) TestInfoEndpointUnauthorized() {\n\treq := httptest.NewRequest(http.MethodGet, \"/api/v1/info\", nil)\n\n\tw := httptest.NewRecorder()\n\ts.router.ServeHTTP(w, req)\n\n\tassert.Equal(s.T(), http.StatusUnauthorized, w.Code)\n}\n\nfunc (s *InfoIntegrationTestSuite) TestInfoEndpointInvalidToken() {\n\treq := httptest.NewRequest(http.MethodGet, \"/api/v1/info\", nil)\n\treq.Header.Set(\"Authorization\", \"Bearer invalid-token\")\n\n\tw := httptest.NewRecorder()\n\ts.router.ServeHTTP(w, req)\n\n\tassert.Equal(s.T(), http.StatusUnauthorized, w.Code)\n}\n\nfunc (s *InfoIntegrationTestSuite) TearDownSuite() {\n\tctx := context.Background()\n\tif s.pg != nil {\n\t\ts.pg.Cleanup(ctx)\n\t}\n}\n",
      "size": 3764,
      "hash": "866abeef9e347a60641045fd3f0fb128e345f0f66a34db095a3ecc9bf35bba43",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    },
    {
      "path": "tests/integration/testcontainer.go",
      "template": true,
      "content": "package integration\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/acheevo/api-template/internal/shared/database\"\n\t\"github.com/testcontainers/testcontainers-go\"\n\t\"github.com/testcontainers/testcontainers-go/modules/postgres\"\n\t\"github.com/testcontainers/testcontainers-go/wait\"\n)\n\nconst (\n\ttestDBName = \"api_template_test\"\n\ttestDBUser = \"testuser\"\n\ttestDBPass = \"testpass\"\n)\n\ntype PostgresContainer struct {\n\tcontainer  testcontainers.Container\n\tdb         *database.Database\n\tconnString string\n}\n\nfunc SetupPostgresContainer(t *testing.T) *PostgresContainer {\n\tctx := context.Background()\n\n\tpgContainer, err := postgres.Run(ctx,\n\t\t\"postgres:16-alpine\",\n\t\tpostgres.WithDatabase(testDBName),\n\t\tpostgres.WithUsername(testDBUser),\n\t\tpostgres.WithPassword(testDBPass),\n\t\ttestcontainers.WithWaitStrategy(\n\t\t\twait.ForLog(\"database system is ready to accept connections\").\n\t\t\t\tWithOccurrence(2).\n\t\t\t\tWithStartupTimeout(30*time.Second),\n\t\t),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to start postgres container: %v\", err)\n\t}\n\n\tconnStr, err := pgContainer.ConnectionString(ctx, \"sslmode=disable\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get connection string: %v\", err)\n\t}\n\n\tdb, err := database.New(connStr, true)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to connect to test database: %v\", err)\n\t}\n\n\t// Set up connection pool for testing\n\tif err := db.SetConnectionPool(1, 5, 30*time.Minute); err != nil {\n\t\tt.Fatalf(\"failed to configure test database connection pool: %v\", err)\n\t}\n\n\treturn \u0026PostgresContainer{\n\t\tcontainer:  pgContainer,\n\t\tdb:         db,\n\t\tconnString: connStr,\n\t}\n}\n\nfunc (pc *PostgresContainer) GetDB() *database.Database {\n\treturn pc.db\n}\n\nfunc (pc *PostgresContainer) GetConnectionString() string {\n\treturn pc.connString\n}\n\nfunc (pc *PostgresContainer) GetHost(ctx context.Context) (string, error) {\n\thost, err := pc.container.Host(ctx)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to get container host: %w\", err)\n\t}\n\treturn host, nil\n}\n\nfunc (pc *PostgresContainer) GetPort(ctx context.Context) (int, error) {\n\tport, err := pc.container.MappedPort(ctx, \"5432\")\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to get mapped port: %w\", err)\n\t}\n\treturn port.Int(), nil\n}\n\nfunc (pc *PostgresContainer) Cleanup(ctx context.Context) error {\n\tif pc.db != nil {\n\t\tpc.db.Close()\n\t}\n\tif pc.container != nil {\n\t\treturn pc.container.Terminate(ctx)\n\t}\n\treturn nil\n}\n",
      "size": 2375,
      "hash": "86445290cebbb1b3f3260f62446f0be44a4da1f8406350d693282672bc13c079",
      "mappings": [
        {
          "find": "\"github.com/acheevo/api-template/",
          "replace": "\"github.com/{{.GitHubRepo}}/"
        }
      ]
    }
  ],
  "hooks": {
    "post_generate": [
      "go mod tidy",
      "go build"
    ]
  },
  "hash": "1b1887c4623584495a893e4944d8e63ff964f663e627a1538fb7b4c368937578",
  "env_config": [
    {
      "name": "HTTP_ADDR",
      "description": "Server listen address and port",
      "example": ":8080"
    },
    {
      "name": "READ_TIMEOUT",
      "description": "Maximum duration for reading the entire request",
      "example": "15s"
    },
    {
      "name": "WRITE_TIMEOUT",
      "description": "Maximum duration before timing out writes of the response",
      "example": "15s"
    },
    {
      "name": "IDLE_TIMEOUT",
      "description": "Maximum time to wait for the next request when keep-alives are enabled",
      "example": "60s"
    },
    {
      "name": "DB_HOST",
      "description": "Database host address",
      "example": "localhost"
    },
    {
      "name": "DB_PORT",
      "description": "Database port number",
      "example": "5432"
    },
    {
      "name": "DB_USER",
      "description": "Database username for authentication",
      "example": "postgres"
    },
    {
      "name": "DB_PASSWORD",
      "description": "Database password for authentication",
      "example": "postgres"
    },
    {
      "name": "DB_NAME",
      "description": "Database name to connect to",
      "example": "api_template"
    },
    {
      "name": "DB_SSL_MODE",
      "description": "SSL mode for database connection (disable, require, verify-ca, verify-full)",
      "example": "disable"
    },
    {
      "name": "DB_MAX_IDLE_CONNS",
      "description": "Maximum number of idle connections in the pool",
      "example": "10"
    },
    {
      "name": "DB_MAX_OPEN_CONNS",
      "description": "Maximum number of open connections to the database",
      "example": "100"
    },
    {
      "name": "DB_CONN_MAX_LIFETIME",
      "description": "Maximum amount of time a connection may be reused",
      "example": "1h"
    },
    {
      "name": "SERVICE_NAME",
      "description": "Name of this service for identification and logging",
      "example": "api-template"
    },
    {
      "name": "SERVICE_VERSION",
      "description": "Version of this service for tracking and compatibility",
      "example": "1.0.0"
    },
    {
      "name": "SERVICE_ID",
      "description": "Unique identifier for this service instance (auto-generated if empty)"
    },
    {
      "name": "LOG_LEVEL",
      "description": "Log level (debug, info, warn, error)",
      "example": "info"
    },
    {
      "name": "ENVIRONMENT",
      "description": "Application environment (development, staging, production)",
      "example": "development"
    },
    {
      "name": "JWT_SECRET",
      "description": "Secret key for signing JWT tokens (CHANGE IN PRODUCTION!)",
      "example": "your-jwt-secret-key"
    },
    {
      "name": "JWT_EXPIRATION",
      "description": "JWT token expiration duration",
      "example": "24h"
    },
    {
      "name": "METRICS_ENABLED",
      "description": "Enable Prometheus metrics collection and /metrics endpoint",
      "example": "true"
    }
  ]
}